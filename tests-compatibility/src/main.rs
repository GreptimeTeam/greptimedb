// Copyright 2023 Greptime Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::io;
use std::io::Write;
use std::path::PathBuf;
use std::process::{Child, Command};
use std::time::Duration;

use client::{Client, Database, DEFAULT_CATALOG_NAME, DEFAULT_SCHEMA_NAME};
use common_telemetry::{error, info};
use common_test_util::config::{generate_config_file, ConfigTemplate, ConfigValues};
use common_test_util::display::ResultDisplayer;
use common_test_util::find_workspace_path;
use common_test_util::ports::check_connectable;

const GRPC_ADDR: &str = "127.0.0.1:24001";

#[tokio::main]
async fn main() {
    common_telemetry::init_default_ut_logging();

    info!("Start to build GreptimeDB ...");
    let target_dir = build_greptimedb();
    info!(
        "Build GreptimeDB success, target dir: {}",
        target_dir.display()
    );

    let mut process = start_standalone(target_dir);
    info!(
        "GreptimeDB standalone is spawned with process id {}",
        process.id()
    );

    verify_data().await;

    process.kill().unwrap();
}

/// Verify the data that reside in the files are correct.
async fn verify_data() {
    if !check_connectable(GRPC_ADDR, Duration::from_secs(10)).await {
        panic!("GreptimeDB standalone is not ready within 10 seconds, quit!");
    }

    let client = Client::with_urls(vec![GRPC_ADDR]);
    let db = Database::new(DEFAULT_CATALOG_NAME, DEFAULT_SCHEMA_NAME, client);

    let result = db.sql("show tables").await;
    let expect = "\
+---------+
| Tables  |
+---------+
| monitor |
| numbers |
+---------+\
";
    assert_eq!(ResultDisplayer(result).display().await, expect);

    let result = db.sql("select count(*) from monitor").await;
    let expect = "\
+----------+
| COUNT(*) |
+----------+
| 20002    |
+----------+\
";
    assert_eq!(ResultDisplayer(result).display().await, expect);

    let result = db
        .sql("select ts, host, cpu, memory from monitor order by ts, host limit 10")
        .await;
    let expect = "\
+-------------------------+-----------+-----+--------+
| ts                      | host      | cpu | memory |
+-------------------------+-----------+-----+--------+
| 2023-12-26T07:46:31.287 | 127.0.0.1 | 0.0 |        |
| 2023-12-26T07:46:31.287 | 127.0.0.2 | 0.3 | 0.5    |
| 2023-12-26T07:46:31.288 | 127.0.0.1 | 1.0 |        |
| 2023-12-26T07:46:31.289 | 127.0.0.1 | 2.0 |        |
| 2023-12-26T07:46:31.290 | 127.0.0.1 | 3.0 |        |
| 2023-12-26T07:46:31.291 | 127.0.0.1 | 4.0 |        |
| 2023-12-26T07:46:31.292 | 127.0.0.1 | 5.0 |        |
| 2023-12-26T07:46:31.293 | 127.0.0.1 | 6.0 |        |
| 2023-12-26T07:46:31.294 | 127.0.0.1 | 7.0 |        |
| 2023-12-26T07:46:31.295 | 127.0.0.1 | 8.0 |        |
+-------------------------+-----------+-----+--------+\
";
    assert_eq!(ResultDisplayer(result).display().await, expect);
}

/// Start the just built GreptimeDB standalone, set it's data home and WAL path to an existing directory.
/// The directory contains a whole dataset that is generated by an old version of GreptimeDB.
/// If the current GreptimeDB starts successfully, it means we have data files compatibility.
fn start_standalone(target_dir: PathBuf) -> Child {
    #[cfg(not(windows))]
    let program = "./greptime";
    #[cfg(windows)]
    let program = "greptime.exe";

    let config_values = ConfigValues {
        wal_dir: find_workspace_path("/tests-compatibility/data_home/wal/")
            .display()
            .to_string(),
        data_home: find_workspace_path("/tests-compatibility/data_home/")
            .display()
            .to_string(),
        is_raft_engine: true,
        grpc_addr: GRPC_ADDR.to_string(),
        ..Default::default()
    };
    let config_file = target_dir
        .join(generate_config_file(
            ConfigTemplate::Standalone,
            config_values,
            &target_dir,
        ))
        .display()
        .to_string();

    let args = vec![
        "--log-level=debug,hyper=warn,tower=warn,datafusion=warn,reqwest=warn,sqlparser=warn,h2=info,opendal=info",
        "standalone",
        "start",
        "-c",
        config_file.as_str(),
    ];

    Command::new(program)
        .current_dir(target_dir)
        .env("TZ", "UTC")
        .args(args)
        .spawn()
        .unwrap()
}

/// Build the GreptimeDB with **current** source codes, returns the directory path to the binary.
fn build_greptimedb() -> PathBuf {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));

    // cd to workspace root
    path.pop();

    let output = Command::new("cargo")
        .current_dir(&path)
        .args(["build", "--bin", "greptime"])
        .output()
        .unwrap();

    if !output.status.success() {
        error!("Failed to build GreptimeDB, {}", output.status);
        io::stdout().write_all(&output.stdout).unwrap();
        io::stderr().write_all(&output.stderr).unwrap();
        panic!();
    }

    path.push("target");
    path.push("debug");
    path
}
