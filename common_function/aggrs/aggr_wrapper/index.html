<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wrapper for making aggregate functions out of state/merge functions of original aggregate functions."><title>common_function::aggrs::aggr_wrapper - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="common_function" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (fa3155a64 2025-09-30)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module aggr_wrapper</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../common_function/index.html">common_<wbr>function</a><span class="version">0.18.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module aggr_<wbr>wrapper</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In common_<wbr>function::<wbr>aggrs</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">common_function</a>::<wbr><a href="../index.html">aggrs</a></div><h1>Module <span>aggr_<wbr>wrapper</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/common_function/aggrs/aggr_wrapper.rs.html#15-744">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wrapper for making aggregate functions out of state/merge functions of original aggregate functions.</p>
<p>i.e. for a aggregate function <code>foo</code>, we will have a state function <code>foo_state</code> and a merge function <code>foo_merge</code>.</p>
<p><code>foo_state</code>’s input args is the same as <code>foo</code>’s, and its output is a state object.
Note that <code>foo_state</code> might have multiple output columns, so it’s a struct array
that each output column is a struct field.
<code>foo_merge</code>’s input arg is the same as <code>foo_state</code>’s output, and its output is the same as <code>foo</code>’s input.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="fix_order/index.html" title="mod common_function::aggrs::aggr_wrapper::fix_order">fix_<wbr>order</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.MergeAccum.html" title="struct common_function::aggrs::aggr_wrapper::MergeAccum">Merge<wbr>Accum</a></dt><dd>The merge accumulator, which modify <code>update_batch</code>’s behavior to accept one struct array which
include the state fields of original aggregate function, and merge said states into original accumulator
the output is the same as original aggregate function</dd><dt><a class="struct" href="struct.MergeWrapper.html" title="struct common_function::aggrs::aggr_wrapper::MergeWrapper">Merge<wbr>Wrapper</a></dt><dd>TODO(discord9): mark this function as non-ser/de able</dd><dt><a class="struct" href="struct.StateAccum.html" title="struct common_function::aggrs::aggr_wrapper::StateAccum">State<wbr>Accum</a></dt><dd>The wrapper’s input is the same as the original aggregate function’s input,
and the output is the state function’s output.</dd><dt><a class="struct" href="struct.StateMergeHelper.html" title="struct common_function::aggrs::aggr_wrapper::StateMergeHelper">State<wbr>Merge<wbr>Helper</a></dt><dd>A wrapper to make an aggregate function out of the state and merge functions of the original aggregate function.
It contains the original aggregate function, the state functions, and the merge function.</dd><dt><a class="struct" href="struct.StateWrapper.html" title="struct common_function::aggrs::aggr_wrapper::StateWrapper">State<wbr>Wrapper</a></dt><dd>Wrapper to make an aggregate function out of a state function.</dd><dt><a class="struct" href="struct.StepAggrPlan.html" title="struct common_function::aggrs::aggr_wrapper::StepAggrPlan">Step<wbr>Aggr<wbr>Plan</a></dt><dd>A struct to hold the two aggregate plans, one for the state function(lower) and one for the merge function(upper).</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.aggr_merge_func_name.html" title="fn common_function::aggrs::aggr_wrapper::aggr_merge_func_name">aggr_<wbr>merge_<wbr>func_<wbr>name</a></dt><dd>Returns the name of the merge function for the given aggregate function name.
The merge function is used to merge the states of the state functions.
The merge function’s name is in the format `__&lt;aggr_name&gt;_merge</dd><dt><a class="fn" href="fn.aggr_state_func_name.html" title="fn common_function::aggrs::aggr_wrapper::aggr_state_func_name">aggr_<wbr>state_<wbr>func_<wbr>name</a></dt><dd>Returns the name of the state function for the given aggregate function name.
The state function is used to compute the state of the aggregate function.
The state function’s name is in the format `__&lt;aggr_name&gt;_state</dd><dt><a class="fn" href="fn.get_aggr_func.html" title="fn common_function::aggrs::aggr_wrapper::get_aggr_func">get_<wbr>aggr_<wbr>func</a></dt><dt><a class="fn" href="fn.is_all_aggr_exprs_steppable.html" title="fn common_function::aggrs::aggr_wrapper::is_all_aggr_exprs_steppable">is_<wbr>all_<wbr>aggr_<wbr>exprs_<wbr>steppable</a></dt><dd>Check if the given aggregate expression is steppable.
As in if it can be split into multiple steps:
i.e. on datanode first call <code>state(input)</code> then
on frontend call <code>calc(merge(state))</code> to get the final result.</dd></dl></section></div></main></body></html>