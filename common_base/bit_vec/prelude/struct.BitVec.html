<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bit-Precision Dynamic Array"><title>BitVec in common_base::bit_vec::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="common_base" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (fa3155a64 2025-09-30)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">BitVec</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../common_base/index.html">common_<wbr>base</a><span class="version">1.0.0-rc.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">BitVec</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#bit-precision-dynamic-array" title="Bit-Precision Dynamic Array">Bit-Precision Dynamic Array</a><ul><li><a href="#documentation-practices" title="Documentation Practices">Documentation Practices</a></li><li><a href="#original" title="Original">Original</a></li><li><a href="#api-differences" title="API Differences">API Differences</a></li><li><a href="#suggested-uses" title="Suggested Uses">Suggested Uses</a></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#other-notes" title="Other Notes">Other Notes</a></li><li><a href="#safety" title="Safety">Safety</a></li></ul></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.bitspan" title="bitspan">bitspan</a></li><li><a href="#structfield.capacity" title="capacity">capacity</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.EMPTY" title="EMPTY">EMPTY</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.append" title="append">append</a></li><li><a href="#method.as_bitptr" title="as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitslice" title="as_bitslice">as_bitslice</a></li><li><a href="#method.as_mut_bitptr" title="as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitslice" title="as_mut_bitslice">as_mut_bitslice</a></li><li><a href="#method.as_mut_ptr" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_slice" title="as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.as_raw_mut_slice" title="as_raw_mut_slice">as_raw_mut_slice</a></li><li><a href="#method.as_raw_slice" title="as_raw_slice">as_raw_slice</a></li><li><a href="#method.as_slice" title="as_slice">as_slice</a></li><li><a href="#method.capacity" title="capacity">capacity</a></li><li><a href="#method.clear" title="clear">clear</a></li><li><a href="#method.drain" title="drain">drain</a></li><li><a href="#method.extend_from_bitslice" title="extend_from_bitslice">extend_from_bitslice</a></li><li><a href="#method.extend_from_raw_slice" title="extend_from_raw_slice">extend_from_raw_slice</a></li><li><a href="#method.extend_from_slice" title="extend_from_slice">extend_from_slice</a></li><li><a href="#method.extend_from_within" title="extend_from_within">extend_from_within</a></li><li><a href="#method.force_align" title="force_align">force_align</a></li><li><a href="#method.from_bitslice" title="from_bitslice">from_bitslice</a></li><li><a href="#method.from_element" title="from_element">from_element</a></li><li><a href="#method.from_raw_parts" title="from_raw_parts">from_raw_parts</a></li><li><a href="#method.from_slice" title="from_slice">from_slice</a></li><li><a href="#method.from_vec" title="from_vec">from_vec</a></li><li><a href="#method.insert" title="insert">insert</a></li><li><a href="#method.into_boxed_bitslice" title="into_boxed_bitslice">into_boxed_bitslice</a></li><li><a href="#method.into_boxed_slice" title="into_boxed_slice">into_boxed_slice</a></li><li><a href="#method.into_raw_parts" title="into_raw_parts">into_raw_parts</a></li><li><a href="#method.into_vec" title="into_vec">into_vec</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.leak" title="leak">leak</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.pop" title="pop">pop</a></li><li><a href="#method.push" title="push">push</a></li><li><a href="#method.remove" title="remove">remove</a></li><li><a href="#method.repeat" title="repeat">repeat</a></li><li><a href="#method.reserve" title="reserve">reserve</a></li><li><a href="#method.reserve_exact" title="reserve_exact">reserve_exact</a></li><li><a href="#method.resize" title="resize">resize</a></li><li><a href="#method.resize_with" title="resize_with">resize_with</a></li><li><a href="#method.retain" title="retain">retain</a></li><li><a href="#method.set_elements" title="set_elements">set_elements</a></li><li><a href="#method.set_len" title="set_len">set_len</a></li><li><a href="#method.set_uninitialized" title="set_uninitialized">set_uninitialized</a></li><li><a href="#method.shrink_to_fit" title="shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.splice" title="splice">splice</a></li><li><a href="#method.split_off" title="split_off">split_off</a></li><li><a href="#method.swap_remove" title="swap_remove">swap_remove</a></li><li><a href="#method.truncate" title="truncate">truncate</a></li><li><a href="#method.try_from_slice" title="try_from_slice">try_from_slice</a></li><li><a href="#method.try_from_vec" title="try_from_vec">try_from_vec</a></li><li><a href="#method.with_capacity" title="with_capacity">with_capacity</a></li></ul><h3><a href="#deref-methods-BitSlice%3CT,+O%3E">Methods from Deref&lt;<wbr>Target=<wbr>BitSlice&lt;<wbr>T, O&gt;&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.align_to" title="align_to">align_to</a></li><li><a href="#method.align_to_mut" title="align_to_mut">align_to_mut</a></li><li><a href="#method.all" title="all">all</a></li><li><a href="#method.any" title="any">any</a></li><li><a href="#method.as_bitptr-1" title="as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitptr_range" title="as_bitptr_range">as_bitptr_range</a></li><li><a href="#method.as_mut_bitptr-1" title="as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitptr_range" title="as_mut_bitptr_range">as_mut_bitptr_range</a></li><li><a href="#method.as_mut_ptr-1" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_ptr_range" title="as_mut_ptr_range">as_mut_ptr_range</a></li><li><a href="#method.as_ptr-1" title="as_ptr">as_ptr</a></li><li><a href="#method.as_ptr_range" title="as_ptr_range">as_ptr_range</a></li><li><a href="#method.bit_domain" title="bit_domain">bit_domain</a></li><li><a href="#method.bit_domain_mut" title="bit_domain_mut">bit_domain_mut</a></li><li><a href="#method.chunks" title="chunks">chunks</a></li><li><a href="#method.chunks_exact" title="chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut" title="chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut" title="chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_bitslice" title="clone_from_bitslice">clone_from_bitslice</a></li><li><a href="#method.clone_from_slice" title="clone_from_slice">clone_from_slice</a></li><li><a href="#method.contains" title="contains">contains</a></li><li><a href="#method.copy_from_bitslice" title="copy_from_bitslice">copy_from_bitslice</a></li><li><a href="#method.copy_from_slice" title="copy_from_slice">copy_from_slice</a></li><li><a href="#method.copy_within" title="copy_within">copy_within</a></li><li><a href="#method.copy_within_unchecked" title="copy_within_unchecked">copy_within_unchecked</a></li><li><a href="#method.count_ones" title="count_ones">count_ones</a></li><li><a href="#method.count_zeros" title="count_zeros">count_zeros</a></li><li><a href="#method.domain" title="domain">domain</a></li><li><a href="#method.domain_mut" title="domain_mut">domain_mut</a></li><li><a href="#method.ends_with" title="ends_with">ends_with</a></li><li><a href="#method.fill" title="fill">fill</a></li><li><a href="#method.fill_with" title="fill_with">fill_with</a></li><li><a href="#method.first" title="first">first</a></li><li><a href="#method.first_mut" title="first_mut">first_mut</a></li><li><a href="#method.first_one" title="first_one">first_one</a></li><li><a href="#method.first_zero" title="first_zero">first_zero</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.get_unchecked" title="get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut" title="get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty-1" title="is_empty">is_empty</a></li><li><a href="#method.iter" title="iter">iter</a></li><li><a href="#method.iter_mut" title="iter_mut">iter_mut</a></li><li><a href="#method.iter_ones" title="iter_ones">iter_ones</a></li><li><a href="#method.iter_zeros" title="iter_zeros">iter_zeros</a></li><li><a href="#method.last" title="last">last</a></li><li><a href="#method.last_mut" title="last_mut">last_mut</a></li><li><a href="#method.last_one" title="last_one">last_one</a></li><li><a href="#method.last_zero" title="last_zero">last_zero</a></li><li><a href="#method.leading_ones" title="leading_ones">leading_ones</a></li><li><a href="#method.leading_zeros" title="leading_zeros">leading_zeros</a></li><li><a href="#method.len-1" title="len">len</a></li><li><a href="#method.not_all" title="not_all">not_all</a></li><li><a href="#method.not_any" title="not_any">not_any</a></li><li><a href="#method.rchunks" title="rchunks">rchunks</a></li><li><a href="#method.rchunks_exact" title="rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut" title="rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut" title="rchunks_mut">rchunks_mut</a></li><li><a href="#method.repeat-1" title="repeat">repeat</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.replace_unchecked" title="replace_unchecked">replace_unchecked</a></li><li><a href="#method.reverse" title="reverse">reverse</a></li><li><a href="#method.rotate_left" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_right" title="rotate_right">rotate_right</a></li><li><a href="#method.rsplit" title="rsplit">rsplit</a></li><li><a href="#method.rsplit_mut" title="rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn" title="rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut" title="rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set" title="set">set</a></li><li><a href="#method.set_aliased" title="set_aliased">set_aliased</a></li><li><a href="#method.set_aliased_unchecked" title="set_aliased_unchecked">set_aliased_unchecked</a></li><li><a href="#method.set_unchecked" title="set_unchecked">set_unchecked</a></li><li><a href="#method.shift_left" title="shift_left">shift_left</a></li><li><a href="#method.shift_right" title="shift_right">shift_right</a></li><li><a href="#method.some" title="some">some</a></li><li><a href="#method.split" title="split">split</a></li><li><a href="#method.split_at" title="split_at">split_at</a></li><li><a href="#method.split_at_mut" title="split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_unchecked" title="split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_at_unchecked_mut" title="split_at_unchecked_mut">split_at_unchecked_mut</a></li><li><a href="#method.split_first" title="split_first">split_first</a></li><li><a href="#method.split_first_mut" title="split_first_mut">split_first_mut</a></li><li><a href="#method.split_inclusive" title="split_inclusive">split_inclusive</a></li><li><a href="#method.split_inclusive_mut" title="split_inclusive_mut">split_inclusive_mut</a></li><li><a href="#method.split_last" title="split_last">split_last</a></li><li><a href="#method.split_last_mut" title="split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut" title="split_mut">split_mut</a></li><li><a href="#method.splitn" title="splitn">splitn</a></li><li><a href="#method.splitn_mut" title="splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with" title="starts_with">starts_with</a></li><li><a href="#method.strip_prefix" title="strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix" title="strip_suffix">strip_suffix</a></li><li><a href="#method.swap" title="swap">swap</a></li><li><a href="#method.swap_unchecked" title="swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_bitslice" title="swap_with_bitslice">swap_with_bitslice</a></li><li><a href="#method.swap_with_slice" title="swap_with_slice">swap_with_slice</a></li><li><a href="#method.to_bitvec" title="to_bitvec">to_bitvec</a></li><li><a href="#method.to_vec" title="to_vec">to_vec</a></li><li><a href="#method.trailing_ones" title="trailing_ones">trailing_ones</a></li><li><a href="#method.trailing_zeros" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.windows" title="windows">windows</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="AsMut&#60;BitSlice&#60;T, O&#62;&#62;">AsMut&#60;BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-AsMut%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="AsMut&#60;BitVec&#60;T, O&#62;&#62;">AsMut&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="AsRef&#60;BitSlice&#60;T, O&#62;&#62;">AsRef&#60;BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-AsRef%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="AsRef&#60;BitVec&#60;T, O&#62;&#62;">AsRef&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-Binary-for-BitVec%3CT,+O%3E" title="Binary">Binary</a></li><li><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitAnd&#60;Rhs&#62;">BitAnd&#60;Rhs&#62;</a></li><li><a href="#impl-BitAndAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitAndAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;">BitAndAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitAndAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitAndAssign&#60;BitVec&#60;T, O&#62;&#62;">BitAndAssign&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitAndAssign&#60;Rhs&#62;">BitAndAssign&#60;Rhs&#62;</a></li><li><a href="#impl-BitField-for-BitVec%3CT,+O%3E" title="BitField">BitField</a></li><li><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitOr&#60;Rhs&#62;">BitOr&#60;Rhs&#62;</a></li><li><a href="#impl-BitOrAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitOrAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;">BitOrAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitOrAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitOrAssign&#60;BitVec&#60;T, O&#62;&#62;">BitOrAssign&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitOrAssign&#60;Rhs&#62;">BitOrAssign&#60;Rhs&#62;</a></li><li><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitXor&#60;Rhs&#62;">BitXor&#60;Rhs&#62;</a></li><li><a href="#impl-BitXorAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitXorAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;">BitXorAssign&#60;&#38;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitXorAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" title="BitXorAssign&#60;BitVec&#60;T, O&#62;&#62;">BitXorAssign&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" title="BitXorAssign&#60;Rhs&#62;">BitXorAssign&#60;Rhs&#62;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="Borrow&#60;BitSlice&#60;T, O&#62;&#62;">Borrow&#60;BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="BorrowMut&#60;BitSlice&#60;T, O&#62;&#62;">BorrowMut&#60;BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-Clone-for-BitVec%3CT,+O%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-BitVec%3CT,+O%3E" title="Debug">Debug</a></li><li><a href="#impl-Default-for-BitVec%3CT,+O%3E" title="Default">Default</a></li><li><a href="#impl-__Deref-for-BitVec%3CT,+O%3E" title="Deref">Deref</a></li><li><a href="#impl-DerefMut-for-BitVec%3CT,+O%3E" title="DerefMut">DerefMut</a></li><li><a href="#impl-Display-for-BitVec%3CT,+O%3E" title="Display">Display</a></li><li><a href="#impl-Drop-for-BitVec%3CT,+O%3E" title="Drop">Drop</a></li><li><a href="#impl-Eq-for-BitVec%3CT,+O%3E" title="Eq">Eq</a></li><li><a href="#impl-Extend%3C%26T%3E-for-BitVec%3CT,+O%3E" title="Extend&#60;&#38;&#39;a T&#62;">Extend&#60;&#38;&#39;a T&#62;</a></li><li><a href="#impl-Extend%3C%26bool%3E-for-BitVec%3CT,+O%3E" title="Extend&#60;&#38;&#39;a bool&#62;">Extend&#60;&#38;&#39;a bool&#62;</a></li><li><a href="#impl-Extend%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" title="Extend&#60;BitRef&#60;&#39;a, M, T2, O2&#62;&#62;">Extend&#60;BitRef&#60;&#39;a, M, T2, O2&#62;&#62;</a></li><li><a href="#impl-Extend%3CT%3E-for-BitVec%3CT,+O%3E" title="Extend&#60;T&#62;">Extend&#60;T&#62;</a></li><li><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CT,+O%3E" title="Extend&#60;bool&#62;">Extend&#60;bool&#62;</a></li><li><a href="#impl-From%3C%26BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="From&#60;&#38;BitSlice&#60;T, O&#62;&#62;">From&#60;&#38;BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-From%3C%26mut+BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="From&#60;&#38;mut BitSlice&#60;T, O&#62;&#62;">From&#60;&#38;mut BitSlice&#60;T, O&#62;&#62;</a></li><li><a href="#impl-From%3CBitArray%3CA,+O%3E%3E-for-BitVec%3C%3CA+as+BitView%3E::Store,+O%3E" title="From&#60;BitArray&#60;A, O&#62;&#62;">From&#60;BitArray&#60;A, O&#62;&#62;</a></li><li><a href="#impl-From%3CBitBox%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" title="From&#60;BitBox&#60;T, O&#62;&#62;">From&#60;BitBox&#60;T, O&#62;&#62;</a></li><li><a href="#impl-From%3CBitVec%3CT,+O%3E%3E-for-BitBox%3CT,+O%3E" title="From&#60;BitVec&#60;T, O&#62;&#62;">From&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-From%3CBitVec%3CT,+O%3E%3E-for-Vec%3CT%3E" title="From&#60;BitVec&#60;T, O&#62;&#62;">From&#60;BitVec&#60;T, O&#62;&#62;</a></li><li><a href="#impl-From%3CCow%3C'a,+BitSlice%3CT,+O%3E%3E%3E-for-BitVec%3CT,+O%3E" title="From&#60;Cow&#60;&#39;a, BitSlice&#60;T, O&#62;&#62;&#62;">From&#60;Cow&#60;&#39;a, BitSlice&#60;T, O&#62;&#62;&#62;</a></li><li><a href="#impl-FromIterator%3C%26T%3E-for-BitVec%3CT,+O%3E" title="FromIterator&#60;&#38;&#39;a T&#62;">FromIterator&#60;&#38;&#39;a T&#62;</a></li><li><a href="#impl-FromIterator%3C%26bool%3E-for-BitVec%3CT,+O%3E" title="FromIterator&#60;&#38;&#39;a bool&#62;">FromIterator&#60;&#38;&#39;a bool&#62;</a></li><li><a href="#impl-FromIterator%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" title="FromIterator&#60;BitRef&#60;&#39;a, M, T2, O2&#62;&#62;">FromIterator&#60;BitRef&#60;&#39;a, M, T2, O2&#62;&#62;</a></li><li><a href="#impl-FromIterator%3CT%3E-for-BitVec%3CT,+O%3E" title="FromIterator&#60;T&#62;">FromIterator&#60;T&#62;</a></li><li><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CT,+O%3E" title="FromIterator&#60;bool&#62;">FromIterator&#60;bool&#62;</a></li><li><a href="#impl-Hash-for-BitVec%3CT,+O%3E" title="Hash">Hash</a></li><li><a href="#impl-Index%3CIdx%3E-for-BitVec%3CT,+O%3E" title="Index&#60;Idx&#62;">Index&#60;Idx&#62;</a></li><li><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CT,+O%3E" title="IndexMut&#60;Idx&#62;">IndexMut&#60;Idx&#62;</a></li><li><a href="#impl-IntoIterator-for-%26BitVec%3CT,+O%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26mut+BitVec%3CT,+O%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-BitVec%3CT,+O%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-LowerHex-for-BitVec%3CT,+O%3E" title="LowerHex">LowerHex</a></li><li><a href="#impl-Not-for-BitVec%3CT,+O%3E" title="Not">Not</a></li><li><a href="#impl-Octal-for-BitVec%3CT,+O%3E" title="Octal">Octal</a></li><li><a href="#impl-Ord-for-BitVec%3CT,+O%3E" title="Ord">Ord</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" title="PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;">PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" title="PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;">PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" title="PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;">PartialEq&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CT,+O%3E" title="PartialEq&#60;Rhs&#62;">PartialEq&#60;Rhs&#62;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" title="PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;">PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" title="PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;">PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" title="PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;">PartialOrd&#60;BitVec&#60;T2, O2&#62;&#62;</a></li><li><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CT,+O%3E" title="PartialOrd&#60;Rhs&#62;">PartialOrd&#60;Rhs&#62;</a></li><li><a href="#impl-Pointer-for-BitVec%3CT,+O%3E" title="Pointer">Pointer</a></li><li><a href="#impl-Read-for-BitVec%3CT,+O%3E" title="Read">Read</a></li><li><a href="#impl-Send-for-BitVec%3CT,+O%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-BitVec%3CT,+O%3E" title="Sync">Sync</a></li><li><a href="#impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CT,+O%3E" title="TryFrom&#60;Vec&#60;T&#62;&#62;">TryFrom&#60;Vec&#60;T&#62;&#62;</a></li><li><a href="#impl-Unpin-for-BitVec%3CT,+O%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UpperHex-for-BitVec%3CT,+O%3E" title="UpperHex">UpperHex</a></li><li><a href="#impl-Write-for-BitVec%3CT,+O%3E" title="Write">Write</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-BitVec%3CT,+O%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-BitVec%3CT,+O%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-BitVec%3CT,+O%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Any-for-T-1" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneAny-for-T" title="CloneAny">CloneAny</a></li><li><a href="#impl-CloneAnySend-for-T" title="CloneAnySend">CloneAnySend</a></li><li><a href="#impl-CloneAnySendSync-for-T" title="CloneAnySendSync">CloneAnySendSync</a></li><li><a href="#impl-CloneAnySync-for-T" title="CloneAnySync">CloneAnySync</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-Comparable%3CK%3E-for-Q" title="Comparable&#60;K&#62;">Comparable&#60;K&#62;</a></li><li><a href="#impl-Conv-for-T" title="Conv">Conv</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-FmtForward-for-T" title="FmtForward">FmtForward</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Pipe-for-T" title="Pipe">Pipe</a></li><li><a href="#impl-Receiver-for-P" title="Receiver">Receiver</a></li><li><a href="#impl-Tap-for-T" title="Tap">Tap</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryConv-for-T" title="TryConv">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In common_<wbr>base::<wbr>bit_<wbr>vec::<wbr>prelude</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">common_base</a>::<wbr><a href="../index.html">bit_vec</a>::<wbr><a href="index.html">prelude</a></div><h1>Struct <span class="struct">BitVec</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code><div class="code-attribute">#[repr(C)]</div>pub struct BitVec&lt;T = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, O = <a class="struct" href="struct.LocalBits.html" title="struct common_base::bit_vec::prelude::LocalBits">Lsb0</a>&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div>{
    bitspan: BitSpan&lt;Mut, T, O&gt;,
    capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bit-precision-dynamic-array"><a class="doc-anchor" href="#bit-precision-dynamic-array">§</a>Bit-Precision Dynamic Array</h2>
<p>This is an analogue to <code>Vec&lt;bool&gt;</code> that stores its data using a compaction
scheme to ensure that each <code>bool</code> takes exactly one bit of memory. It is similar
to the C++ type <a href="https://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a>, but uses <code>bitvec</code>’s type parameter system
to provide more detailed control over the in-memory representation.</p>
<p>This is <em>always</em> a heap allocation. If you know your sizes at compile-time, you
may prefer to use <a href="struct.BitArray.html" title="struct common_base::bit_vec::prelude::BitArray"><code>BitArray</code></a> instead, which is able to store its data as an
immediate value rather than through an indirection.</p>
<h3 id="documentation-practices"><a class="doc-anchor" href="#documentation-practices">§</a>Documentation Practices</h3>
<p><code>BitVec</code> exactly replicates the API of the standard-library <code>Vec</code> type,
including inherent methods, trait implementations, and relationships with the
<a href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice"><code>BitSlice</code></a> slice analogue.</p>
<p>Items that are either direct ports, or renamed variants, of standard-library
APIs will have a <code>## Original</code> section that links to their standard-library
documentation. Items that map to standard-library APIs but have a different API
signature will also have an <code>## API Differences</code> section that describes what
the difference is, why it exists, and how to transform your code to fit it. For
example:</p>
<h3 id="original"><a class="doc-anchor" href="#original">§</a>Original</h3>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;T&gt;</code></a></p>
<h3 id="api-differences"><a class="doc-anchor" href="#api-differences">§</a>API Differences</h3>
<p>As with all <code>bitvec</code> data structures, this takes two type parameters <code>&lt;T, O&gt;</code>
that govern the bit-vector’s storage representation in the underlying memory,
and does <em>not</em> take a type parameter to govern what data type it stores (always
<code>bool</code>)</p>
<h3 id="suggested-uses"><a class="doc-anchor" href="#suggested-uses">§</a>Suggested Uses</h3>
<p><code>BitVec</code> is able to act as a compacted <code>usize =&gt; bool</code> dictionary, and is useful
for holding large collections of truthiness. For instance, you might replace a
<code>Vec&lt;Option&lt;T&gt;&gt;</code> with a <code>(BitVec, Vec&lt;MaybeUninit&lt;T&gt;&gt;</code>) to cut down on the
resident size of the discriminant.</p>
<p>Through the <a href="trait._.html" title="trait common_base::bit_vec::prelude::_"><code>BitField</code></a> trait, <code>BitVec</code> is also able to act as a transport
buffer for data that can be marshalled as integers. Serializing data to a
narrower compacted form, or deserializing data <em>from</em> that form, can be easily
accomplished by viewing subsets of a bit-vector and storing integers into, or
loading integers out of, that subset. As an example, transporting four ten-bit
integers can be done in five bytes instead of eight like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[u8, Msb0; <span class="number">0</span>; <span class="number">40</span>];
bv[<span class="number">0 </span>.. <span class="number">10</span>].store::&lt;u16&gt;(<span class="number">0x3A8</span>);
bv[<span class="number">10 </span>.. <span class="number">20</span>].store::&lt;u16&gt;(<span class="number">0x2F9</span>);
bv[<span class="number">20 </span>.. <span class="number">30</span>].store::&lt;u16&gt;(<span class="number">0x154</span>);
bv[<span class="number">30 </span>.. <span class="number">40</span>].store::&lt;u16&gt;(<span class="number">0x06D</span>);</code></pre></div>
<p>If you wish to use bit-field memory representations as <code>struct</code> fields rather
than a transport buffer, consider <code>BitArray</code> instead: that type keeps its data
as an immediate, and is more likely to act like a C struct with bitfields.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p><code>BitVec</code> has exactly the same API as <code>Vec&lt;bool&gt;</code>, and even extends it with some
of <code>Vec&lt;T&gt;</code>’s behaviors. As a brief tour:</p>
<h4 id="push-and-pop"><a class="doc-anchor" href="#push-and-pop">§</a>Push and Pop</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::new();
bv.push(<span class="bool-val">false</span>);
bv.push(<span class="bool-val">true</span>);

<span class="macro">assert_eq!</span>(bv.len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv[<span class="number">0</span>], <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bv.pop(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">1</span>);</code></pre></div><h4 id="writing-into-a-bit-vector"><a class="doc-anchor" href="#writing-into-a-bit-vector">§</a>Writing Into a Bit-Vector</h4>
<p>The only <code>Vec&lt;bool&gt;</code> API that <code>BitVec</code> does <em>not</em> implement is <code>IndexMut</code>,
because that is not yet possible. Instead, <a href="struct.BitSlice.html#method.get_mut" title="method common_base::bit_vec::prelude::BitSlice::get_mut"><code>.get_mut()</code></a> can produce a proxy
reference, or <a href="struct.BitSlice.html#method.set" title="method common_base::bit_vec::prelude::BitSlice::set"><code>.set()</code></a> can take an index and a value to write.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::new();
bv.push(<span class="bool-val">false</span>);

<span class="kw-2">*</span>bv.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
<span class="macro">assert!</span>(bv[<span class="number">0</span>]);
bv.set(<span class="number">0</span>, <span class="bool-val">false</span>);
<span class="macro">assert!</span>(!bv[<span class="number">0</span>]);</code></pre></div><h4 id="macro-construction"><a class="doc-anchor" href="#macro-construction">§</a>Macro Construction</h4>
<p>Like <code>Vec</code>, <code>BitVec</code> also has a macro constructor: <a href="macro.bitvec.html" title="macro common_base::bit_vec::prelude::bitvec"><code>bitvec!</code></a> takes a sequence
of bit expressions and encodes them at compile-time into a suitable buffer. At
run-time, this buffer is copied into the heap as a <code>BitVec</code> with no extra cost
beyond the allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[u16, Msb0; <span class="number">1</span>; <span class="number">20</span>];</code></pre></div><h4 id="borrowing-as-bitslice"><a class="doc-anchor" href="#borrowing-as-bitslice">§</a>Borrowing as <code>BitSlice</code></h4>
<p><code>BitVec</code> lends its buffer as a <code>BitSlice</code>, so you can freely give permission to
view or modify the contained data without affecting the allocation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>read_bitslice(bits: <span class="kw-2">&amp;</span>BitSlice) {
  <span class="comment">// …
</span>}

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">30</span>];
read_bitslice(<span class="kw-2">&amp;</span>bv);
<span class="kw">let </span>bs: <span class="kw-2">&amp;</span>BitSlice = <span class="kw-2">&amp;</span>bv;</code></pre></div><h3 id="other-notes"><a class="doc-anchor" href="#other-notes">§</a>Other Notes</h3>
<p>The default type parameters are <code>&lt;usize, Lsb0&gt;</code>. This is the most performant
pair when operating on memory, but likely does not match your needs if you are
using <code>BitVec</code> to represent a transport buffer. See <a href="https://bitvecto-rs.github.io/bitvec/type-parameters.html">the user guide</a> for
more details on how the type parameters govern memory representation.</p>
<p>Applications, or single-purpose libraries, built atop <code>bitvec</code> will likely want
to create a <code>type</code> alias with specific type parameters for their usage. <code>bitvec</code>
is fully generic over the ordering/storage types, but this generality is rarely
useful for client crates to propagate. <code>&lt;usize, Lsb0&gt;</code> is fastest; <code>&lt;u8, Msb0&gt;</code>
matches what most debugger views of memory will print, and the rest are
documented in the guide.</p>
<h3 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h3>
<p>Unlike the other data structures in this crate, <code>BitVec</code> is uniquely able to
hold uninitialized memory and produce pointers into it. As described in the
<a href="crate::access::BitAccess"><code>BitAccess</code></a> documentation, this crate is categorically unable to operate on
uninitialized memory in any way. In particular, you may not allocate a buffer
using <a href="struct.BitVec.html#method.with_capacity" title="associated function common_base::bit_vec::prelude::BitVec::with_capacity"><code>::with_capacity()</code></a>, then use <a href="struct.BitSlice.html#method.as_mut_bitptr" title="method common_base::bit_vec::prelude::BitSlice::as_mut_bitptr"><code>.as_mut_bitptr()</code></a> to create a pointer
used to write into the uninitialized buffer.</p>
<p>You must always initialize the buffer contents of a <code>BitVec</code> before attempting
to view its contents. You can accomplish this through safe APIs such as
<code>.push()</code>, <code>.extend()</code>, or <code>.reserve()</code>. These are all guaranteed to safely
initialize the memory elements underlying the <code>BitVec</code> buffer without incurring
undefined behavior in their operation.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.bitspan" class="structfield section-header"><a href="#structfield.bitspan" class="anchor field">§</a><code>bitspan: BitSpan&lt;Mut, T, O&gt;</code></span><span id="structfield.capacity" class="structfield section-header"><a href="#structfield.capacity" class="anchor field">§</a><code>capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><p>Port of the <code>Vec&lt;T&gt;</code> inherent API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Constructs a new, empty, bit-vector.</p>
<p>This does not allocate until bits are <a href="struct.BitVec.html#method.push" title="method common_base::bit_vec::prelude::BitVec::push"><code>.push()</code></a>ed into it, or space is
explicitly <a href="struct.BitVec.html#method.reserve" title="method common_base::bit_vec::prelude::BitVec::reserve"><code>.reserve()</code></a>d.</p>
<h6 id="original-1"><a class="doc-anchor" href="#original-1">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.new" title="associated function alloc::vec::Vec::new"><code>Vec::new</code></a></p>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = BitVec::&lt;u8, Msb0&gt;::new();
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_capacity" class="method"><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fn">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Allocates a new, empty, bit-vector with space for at least <code>capacity</code>
bits before reallocating.</p>
<h6 id="original-2"><a class="doc-anchor" href="#original-2">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.with_capacity" title="associated function alloc::vec::Vec::with_capacity"><code>Vec::with_capacity</code></a></p>
<h6 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h6>
<p>This panics if the requested capacity is longer than what the bit-vector
can represent. See <a href="struct.BitSlice.html#associatedconstant.MAX_BITS" title="associated constant common_base::bit_vec::prelude::BitSlice::MAX_BITS"><code>BitSlice::MAX_BITS</code></a>.</p>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">128</span>);

<span class="macro">assert!</span>(bv.is_empty());
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">128</span>);

<span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">128 </span>{
  bv.push(i &amp; <span class="number">0xC0 </span>== i);
}
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">128</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">128</span>);

bv.push(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">129</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">129</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_raw_parts" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts" class="fn">from_raw_parts</a>(
    bitptr: <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;,
    length: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Constructs a bit-vector handle from its constituent fields.</p>
<h6 id="original-3"><a class="doc-anchor" href="#original-3">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.from_raw_parts" title="associated function alloc::vec::Vec::from_raw_parts"><code>Vec::from_raw_parts</code></a></p>
<h6 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h6>
<p>The <strong>only</strong> acceptable argument values for this function are those that
were previously produced by calling <a href="struct.BitVec.html#method.into_raw_parts" title="method common_base::bit_vec::prelude::BitVec::into_raw_parts"><code>.into_raw_parts()</code></a>. Furthermore,
you may only call this <strong>at most once</strong> on any set of arguments. Using
the same arguments in more than one call to this function will result in
a double- or use-after free error.</p>
<p>Attempting to conjure your own values and pass them into this function
will break the allocator state.</p>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>(bitptr, len, capa) = bv.into_raw_parts();
<span class="kw">let </span>bv2 = <span class="kw">unsafe </span>{
  BitVec::from_raw_parts(bitptr, len, capa)
};
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_raw_parts" class="method"><h4 class="code-header">pub fn <a href="#method.into_raw_parts" class="fn">into_raw_parts</a>(self) -&gt; (<a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Decomposes a bit-vector into its constituent member fields.</p>
<p>This disarms the destructor. In order to prevent a memory leak, you must
pass <strong>these exact values</strong> back into <a href="struct.BitVec.html#method.from_raw_parts" title="associated function common_base::bit_vec::prelude::BitVec::from_raw_parts"><code>::from_raw_parts()</code></a>.</p>
<h6 id="original-4"><a class="doc-anchor" href="#original-4">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.into_raw_parts" title="method alloc::vec::Vec::into_raw_parts"><code>Vec::into_raw_parts</code></a></p>
<h6 id="api-differences-1"><a class="doc-anchor" href="#api-differences-1">§</a>API Differences</h6>
<p>This method is still unstable as of 1.54. It is provided here as a
convenience, under the expectation that the standard-library method will
stabilize as-is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capacity" class="method"><h4 class="code-header">pub fn <a href="#method.capacity" class="fn">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the allocation capacity, measured in bits.</p>
<p>This counts how many total bits the bit-vector can store before it must
perform a reällocation to acquire more memory.</p>
<p>If the capacity is not a multiple of 8, you should call
<a href="struct.BitVec.html#method.force_align" title="method common_base::bit_vec::prelude::BitVec::force_align"><code>.force_align()</code></a>.</p>
<h6 id="original-5"><a class="doc-anchor" href="#original-5">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.capacity" title="method alloc::vec::Vec::capacity"><code>Vec::capacity</code></a></p>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reserve" class="method"><h4 class="code-header">pub fn <a href="#method.reserve" class="fn">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Ensures that the bit-vector has allocation capacity for <em>at least</em>
<code>additional</code> more bits to be appended to it.</p>
<p>For convenience, this method <em>guarantees</em> that the underlying memory for
<code>self[.. self.len() + additional]</code> is initialized, and may be safely
accessed directly without requiring use of <code>.push()</code> or <code>.extend()</code> to
initialize it.</p>
<p>Newly-allocated memory is always initialized to zero. It is still <em>dead</em>
until the bit-vector is grown (by <code>.push()</code>, <code>.extend()</code>, or
<code>.set_len()</code>), but direct access will not trigger UB.</p>
<h6 id="original-6"><a class="doc-anchor" href="#original-6">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.reserve" title="method alloc::vec::Vec::reserve"><code>Vec::reserve</code></a></p>
<h6 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h6>
<p>This panics if the new capacity exceeds the bit-vector’s maximum.</p>
<h6 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">80</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">80</span>);
bv.reserve(<span class="number">800</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">800</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_exact" class="method"><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fn">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Ensures that the bit-vector has allocation capacity for <em>at least</em>
<code>additional</code> more bits to be appended to it.</p>
<p>This differs from <a href="struct.BitVec.html#method.reserve" title="method common_base::bit_vec::prelude::BitVec::reserve"><code>.reserve()</code></a> by requesting that the allocator
provide the minimum capacity necessary, rather than a potentially larger
amount that the allocator may find more convenient.</p>
<p>Remember that this is a <em>request</em>: the allocator provides what it
provides, and you cannot rely on the new capacity to be exactly minimal.
You should still prefer <code>.reserve()</code>, especially if you expect to append
to the bit-vector in the future.</p>
<h6 id="original-7"><a class="doc-anchor" href="#original-7">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.reserve_exact" title="method alloc::vec::Vec::reserve_exact"><code>Vec::reserve_exact</code></a></p>
<h6 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h6>
<p>This panics if the new capacity exceeds the bit-vector’s maximum.</p>
<h6 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">80</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">80</span>);
bv.reserve_exact(<span class="number">800</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">800</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method"><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fn">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Releases excess capacity back to the allocator.</p>
<p>Like <a href="struct.BitVec.html#method.reserve_exact" title="method common_base::bit_vec::prelude::BitVec::reserve_exact"><code>.reserve_exact()</code></a>, this is a <em>request</em> to the allocator, not a
command. The allocator may reclaim excess memory or may not.</p>
<h6 id="original-8"><a class="doc-anchor" href="#original-8">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.shrink_to_fit" title="method alloc::vec::Vec::shrink_to_fit"><code>Vec::shrink_to_fit</code></a></p>
<h6 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">1000</span>);
bv.push(<span class="bool-val">true</span>);
bv.shrink_to_fit();</code></pre></div></div></details><section id="method.into_boxed_slice" class="method"><h4 class="code-header">pub fn <a href="#method.into_boxed_slice" class="fn">into_boxed_slice</a>(self) -&gt; <a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: prefer `.into_boxed_bitslice() instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.truncate" class="method"><h4 class="code-header">pub fn <a href="#method.truncate" class="fn">truncate</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shortens the bit-vector, keeping the first <code>new_len</code> bits and discarding
the rest.</p>
<p>If <code>len</code> is greater than the bit-vector’s current length, this has no
effect.</p>
<p>The <a href="struct.BitVec.html#method.drain" title="method common_base::bit_vec::prelude::BitVec::drain"><code>.drain()</code></a> method can emulate <code>.truncate()</code>, except that it yields
the excess bits rather than discarding them.</p>
<p>Note that this has no effect on the allocated capacity of the
bit-vector, <strong>nor does it erase truncated memory</strong>. Bits in the
allocated memory that are outside of the <a href="struct.BitVec.html#method.as_bitslice" title="method common_base::bit_vec::prelude::BitVec::as_bitslice"><code>.as_bitslice()</code></a> view are
always considered to have <em>initialized</em>, but <strong>unspecified</strong>, values,
and you cannot rely on them to be zero.</p>
<h6 id="original-9"><a class="doc-anchor" href="#original-9">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.truncate" title="method alloc::vec::Vec::truncate"><code>Vec::truncate</code></a></p>
<h6 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h6>
<p>Truncating a five-bit vector to two bits:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.truncate(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">2</span>);
<span class="macro">assert!</span>(bv.as_raw_slice()[<span class="number">0</span>].count_ones() &gt;= <span class="number">2</span>);</code></pre></div>
<p>No truncation occurs when <code>len</code> is greater than the bit-vector’s current
length:</p>
</div></details><section id="method.as_slice" class="method"><h4 class="code-header">pub fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;T, O&gt;">ⓘ</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_bitslice()</code> instead</span></div></span><section id="method.as_mut_slice" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;T, O&gt;">ⓘ</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_mut_bitslice()</code> instead</span></div></span><section id="method.as_ptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Const, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_bitptr()</code> instead</span></div></span><section id="method.as_mut_ptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_mut_bitptr()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.set_len" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.set_len" class="fn">set_len</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Resizes a bit-vector to a new length.</p>
<h6 id="original-10"><a class="doc-anchor" href="#original-10">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.set_len" title="method alloc::vec::Vec::set_len"><code>Vec::set_len</code></a></p>
<h6 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h6>
<p><strong>NOT ALL MEMORY IN THE ALLOCATION IS INITIALIZED!</strong></p>
<p>Memory in a bit-vector’s allocation is only initialized when the
bit-vector grows into it normally (through <a href="struct.BitVec.html#method.push" title="method common_base::bit_vec::prelude::BitVec::push"><code>.push()</code></a> or one of the
various <code>.extend*()</code> methods). Setting the length to a value beyond what
was previously initialized, but still within the allocation, is
undefined behavior.</p>
<p>The caller is responsible for ensuring that all memory up to (but not
including) the new length has already been initialized.</p>
<h6 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h6>
<p>This panics if <code>new_len</code> exceeds the capacity as reported by
<a href="struct.BitVec.html#method.capacity" title="method common_base::bit_vec::prelude::BitVec::capacity"><code>.capacity()</code></a>.</p>
<h6 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">unsafe </span>{
  <span class="comment">// The default storage type, `usize`, is at least 32 bits.
  </span>bv.set_len(<span class="number">32</span>);
}
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[
  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
]);
<span class="comment">//  `BitVec` guarantees that newly-initialized memory is zeroed.</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_remove" class="method"><h4 class="code-header">pub fn <a href="#method.swap_remove" class="fn">swap_remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Takes a bit out of the bit-vector.</p>
<p>The empty slot is filled with the last bit in the bit-vector, rather
than shunting <code>index + 1 .. self.len()</code> down by one.</p>
<h6 id="original-11"><a class="doc-anchor" href="#original-11">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.swap_remove" title="method alloc::vec::Vec::swap_remove"><code>Vec::swap_remove</code></a></p>
<h6 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h6>
<p>This panics if <code>index</code> is out of bounds (<code>self.len()</code> or greater).</p>
<h6 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!bv.swap_remove(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Inserts a bit at a given position, shifting all bits after it one spot
to the right.</p>
<p><code>index</code> may be any value up to <em>and including</em> <code>self.len()</code>. If it is
<code>self.len()</code>, it behaves equivalently to <code>.push()</code>.</p>
<h6 id="original-12"><a class="doc-anchor" href="#original-12">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.insert" title="method alloc::vec::Vec::insert"><code>Vec::insert</code></a></p>
<h6 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h6>
<p>This panics if <code>index</code> is out of bounds (including <code>self.len()</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes a bit at a given position, shifting all bits after it one spot
to the left.</p>
<p><code>index</code> may be any value up to, but <strong>not</strong> including, <code>self.len()</code>.</p>
<h6 id="original-13"><a class="doc-anchor" href="#original-13">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.remove" title="method alloc::vec::Vec::remove"><code>Vec::remove</code></a></p>
<h6 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h6>
<p>This panics if <code>index</code> is out of bounds (excluding <code>self.len()</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><h4 class="code-header">pub fn <a href="#method.retain" class="fn">retain</a>&lt;F&gt;(&amp;mut self, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Retains only the bits that the predicate allows.</p>
<p>Bits are deleted from the vector when the predicate function returns
false. This function is linear in <code>self.len()</code>.</p>
<h6 id="original-14"><a class="doc-anchor" href="#original-14">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.retain" title="method alloc::vec::Vec::retain"><code>Vec::retain</code></a></p>
<h6 id="api-differences-2"><a class="doc-anchor" href="#api-differences-2">§</a>API Differences</h6>
<p>The predicate receives both the index of the bit as well as its value,
in order to allow the predicate to have more than one bit of
keep/discard information.</p>
<h6 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.retain(|idx, <span class="kw">_</span>| idx % <span class="number">2 </span>== <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>,    <span class="number">0</span>,    <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Appends a single bit to the vector.</p>
<h6 id="original-15"><a class="doc-anchor" href="#original-15">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.push" title="method alloc::vec::Vec::push"><code>Vec::push</code></a></p>
<h6 id="panics-7"><a class="doc-anchor" href="#panics-7">§</a>Panics</h6>
<p>This panics if the push would cause the bit-vector to exceed its maximum
capacity.</p>
<h6 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>];
bv.push(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.as_bitslice(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><h4 class="code-header">pub fn <a href="#method.pop" class="fn">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Attempts to remove the trailing bit from the bit-vector.</p>
<p>This returns <code>None</code> if the bit-vector is empty.</p>
<h6 id="original-16"><a class="doc-anchor" href="#original-16">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.pop" title="method alloc::vec::Vec::pop"><code>Vec::pop</code></a></p>
<h6 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(bv.pop().unwrap());
<span class="macro">assert!</span>(!bv.pop().unwrap());
<span class="macro">assert!</span>(bv.pop().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.append" class="method"><h4 class="code-header">pub fn <a href="#method.append" class="fn">append</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Moves all the bits out of <code>other</code> into the back of <code>self</code>.</p>
<p>The <code>other</code> bit-vector is emptied after this occurs.</p>
<h6 id="original-17"><a class="doc-anchor" href="#original-17">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.append" title="method alloc::vec::Vec::append"><code>Vec::append</code></a></p>
<h6 id="api-differences-3"><a class="doc-anchor" href="#api-differences-3">§</a>API Differences</h6>
<p>This permits <code>other</code> to have different type parameters than <code>self</code>, and
does not require that it be literally <code>Self</code>.</p>
<h6 id="panics-8"><a class="doc-anchor" href="#panics-8">§</a>Panics</h6>
<p>This panics if <code>self.len() + other.len()</code> exceeds the maximum capacity
of a bit-vector.</p>
<h6 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv1 = <span class="macro">bitvec!</span>[u16, Msb0; <span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>bv2 = <span class="macro">bitvec!</span>[u32, Lsb0; <span class="number">1</span>; <span class="number">10</span>];

bv1.append(<span class="kw-2">&amp;mut </span>bv2);

<span class="macro">assert_eq!</span>(bv1.count_ones(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(bv1.count_zeros(), <span class="number">10</span>);
<span class="macro">assert!</span>(bv2.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.drain" class="method"><h4 class="code-header">pub fn <a href="#method.drain" class="fn">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; Drain&lt;'_, T, O&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Iterates over a portion of the bit-vector, <em>removing</em> all yielded bits
from it.</p>
<p>When the iterator drops, <em>all</em> bits in its coverage are removed from
<code>self</code>, even if the iterator did not yield them. If the iterator is
leaked or otherwise forgotten, and its destructor never runs, then the
amount of un-yielded bits removed from the bit-vector is not specified.</p>
<h6 id="original-18"><a class="doc-anchor" href="#original-18">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.drain" title="method alloc::vec::Vec::drain"><code>Vec::drain</code></a></p>
<h6 id="panics-9"><a class="doc-anchor" href="#panics-9">§</a>Panics</h6>
<p>This panics if <code>range</code> departs <code>0 .. self.len()</code>.</p>
<h6 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2 = bv.drain(<span class="number">1 </span>..= <span class="number">3</span>).collect::&lt;BitVec&gt;();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>,          <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="comment">// A full range clears the bit-vector.
</span>bv.drain(..);
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Empties the bit-vector.</p>
<p>This does not affect the allocated capacity.</p>
<h6 id="original-19"><a class="doc-anchor" href="#original-19">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.clear" title="method alloc::vec::Vec::clear"><code>Vec::clear</code></a></p>
<h6 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.clear();
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the length of the bit-vector.</p>
<p>This is equivalent to <code>BitSlice::len</code>; it is provided as an inherent
method here rather than relying on <code>Deref</code> forwarding so that you can
write <code>BitVec::len</code> as a named function item.</p>
<h6 id="original-20"><a class="doc-anchor" href="#original-20">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.len" title="method alloc::vec::Vec::len"><code>Vec::len</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if the bit-vector is empty.</p>
<p>This is equivalent to <code>BitSlice::is_empty</code>; it is provided as an
inherent method here rather than relying on <code>Deref</code> forwarding so that
you can write <code>BitVec::is_empty</code> as a named function item.</p>
<h6 id="original-21"><a class="doc-anchor" href="#original-21">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.is_empty" title="method alloc::vec::Vec::is_empty"><code>Vec::is_empty</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_off" class="method"><h4 class="code-header">pub fn <a href="#method.split_off" class="fn">split_off</a>(&amp;mut self, at: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Splits the bit-vector in half at an index, moving <code>self[at ..]</code> out into
a new bit-vector.</p>
<h6 id="original-22"><a class="doc-anchor" href="#original-22">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.split_off" title="method alloc::vec::Vec::split_off"><code>Vec::split_off</code></a></p>
<h6 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2 = bv.split_off(<span class="number">2</span>);
<span class="macro">assert_eq!</span>((<span class="kw-2">&amp;*</span>bv, <span class="kw-2">&amp;*</span>bv2), (<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>], <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.resize_with" class="method"><h4 class="code-header">pub fn <a href="#method.resize_with" class="fn">resize_with</a>&lt;F&gt;(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Resizes the bit-vector to a new length, using a function to produce each
inserted bit.</p>
<p>If <code>new_len</code> is less than <code>self.len()</code>, this is a truncate operation; if
it is greater, then <code>self</code> is extended by repeatedly pushing <code>func()</code>.</p>
<h6 id="original-23"><a class="doc-anchor" href="#original-23">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.resize_with" title="method alloc::vec::Vec::resize_with"><code>Vec::resize_with</code></a></p>
<h6 id="api-differences-4"><a class="doc-anchor" href="#api-differences-4">§</a>API Differences</h6>
<p>The generator function receives the index into which its bit will be
placed.</p>
<h6 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">2</span>];
bv.resize_with(<span class="number">5</span>, |idx| idx % <span class="number">2 </span>== <span class="number">1</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leak" class="method"><h4 class="code-header">pub fn <a href="#method.leak" class="fn">leak</a>&lt;'a&gt;(self) -&gt; &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;&#39;a mut BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Destroys the <code>BitVec</code> handle without destroying the bit-vector
allocation. The allocation is returned as an <code>&amp;mut BitSlice</code> that lasts
for the remaining program lifetime.</p>
<p>You <em>may</em> call <a href="struct.BitBox.html#method.from_raw" title="associated function common_base::bit_vec::prelude::BitBox::from_raw"><code>BitBox::from_raw</code></a> on this slice handle exactly once in
order to reap the allocation before program exit. That function takes a
mutable pointer, not a mutable reference, so you must ensure that the
returned reference is never used again after restoring the allocation
handle.</p>
<h6 id="original-24"><a class="doc-anchor" href="#original-24">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.leak" title="method alloc::vec::Vec::leak"><code>Vec::leak</code></a></p>
<h6 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>static_bits: <span class="kw-2">&amp;</span><span class="lifetime">'static </span><span class="kw-2">mut </span>BitSlice = bv.leak();
static_bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(static_bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="kw">let </span>bb = <span class="kw">unsafe </span>{ BitBox::from_raw(static_bits) };
<span class="comment">// static_bits may no longer be used.
</span>drop(bb); <span class="comment">// explicitly reap memory before program exit</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.resize" class="method"><h4 class="code-header">pub fn <a href="#method.resize" class="fn">resize</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Resizes the bit-vector to a new length. New bits are initialized to
<code>value</code>.</p>
<h6 id="original-25"><a class="doc-anchor" href="#original-25">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.resize" title="method alloc::vec::Vec::resize"><code>Vec::resize</code></a></p>
<h6 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">2</span>];
bv.resize(<span class="number">5</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div></div></details><section id="method.extend_from_slice" class="method"><h4 class="code-header">pub fn <a href="#method.extend_from_slice" class="fn">extend_from_slice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.extend_from_bitslice()</code> or <code>.extend_from_raw_slice()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.extend_from_within" class="method"><h4 class="code-header">pub fn <a href="#method.extend_from_within" class="fn">extend_from_within</a>&lt;R&gt;(&amp;mut self, src: R)<div class="where">where
    R: RangeExt&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Extends <code>self</code> by copying an internal range of its bit-slice as the
region to append.</p>
<h6 id="original-26"><a class="doc-anchor" href="#original-26">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.extend_from_within" title="method alloc::vec::Vec::extend_from_within"><code>Vec::extend_from_within</code></a></p>
<h6 id="panics-10"><a class="doc-anchor" href="#panics-10">§</a>Panics</h6>
<p>This panics if <code>src</code> is not within <code>0 .. self.len()</code>.</p>
<h6 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.extend_from_within(<span class="number">1 </span>.. <span class="number">4</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.splice" class="method"><h4 class="code-header">pub fn <a href="#method.splice" class="fn">splice</a>&lt;R, I&gt;(
    &amp;mut self,
    range: R,
    replace_with: I,
) -&gt; Splice&lt;'_, T, O, &lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Modifies <a href="struct.BitVec.html#method.drain" title="method common_base::bit_vec::prelude::BitVec::drain"><code>self.drain()</code></a> so that the removed bit-slice is instead
replaced with the contents of another bit-stream.</p>
<p>As with <code>.drain()</code>, the specified range is always removed from the
bit-vector even if the splicer is not fully consumed, and the splicer
does not specify how many bits are removed if it leaks.</p>
<p>The replacement source is only consumed when the splicer drops; however,
it may be pulled before then. The replacement source cannot assume that
there will be a delay between creation of the splicer and when it must
begin producing bits.</p>
<p>This copies the <code>Vec::splice</code> implementation; see its documentation for
more details about how the replacement should act.</p>
<h6 id="original-27"><a class="doc-anchor" href="#original-27">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.splice" title="method alloc::vec::Vec::splice"><code>Vec::splice</code></a></p>
<h6 id="panics-11"><a class="doc-anchor" href="#panics-11">§</a>Panics</h6>
<p>This panics if <code>range</code> departs <code>0 .. self.len()</code>.</p>
<h6 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">//                   a  b  c
</span><span class="kw">let </span><span class="kw-2">mut </span>yank = bv.splice(
  .. <span class="number">2</span>,
  <span class="macro">bits!</span>[<span class="kw">static </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>].iter().by_vals(),
<span class="comment">//             d  e  f
</span>);

<span class="macro">assert!</span>(!yank.next().unwrap()); <span class="comment">// a
</span><span class="macro">assert!</span>(yank.next().unwrap()); <span class="comment">// b
</span>drop(yank);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                   d  e  f  c</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CT,+O%3E-1" class="impl"><a href="#impl-BitVec%3CT,+O%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><p>Constructors.</p>
</div></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.EMPTY" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.EMPTY" class="constant">EMPTY</a>: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class="docblock"><p>An empty bit-vector with no backing allocation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(bit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a new bit-vector by repeating a bit for the desired length.</p>
<h6 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>zeros = BitVec::&lt;u8, Msb0&gt;::repeat(<span class="bool-val">false</span>, <span class="number">50</span>);
<span class="kw">let </span>ones = BitVec::&lt;u16, Lsb0&gt;::repeat(<span class="bool-val">true</span>, <span class="number">50</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.from_bitslice" class="fn">from_bitslice</a>(slice: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Copies the contents of a bit-slice into a new heap allocation.</p>
<p>This copies the raw underlying elements into a new allocation, and sets
the produced bit-vector to use the same memory layout as the originating
bit-slice. This means that it may begin at any bit in the first element,
not just the zeroth bit. If you require this property, call
<a href="struct.BitVec.html#method.force_align" title="method common_base::bit_vec::prelude::BitVec::force_align"><code>.force_align()</code></a>.</p>
<p>Dead bits in the copied memory elements are guaranteed to be zeroed.</p>
<h6 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = BitVec::from_bitslice(bits);
<span class="macro">assert_eq!</span>(bv, bits);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_element" class="method"><h4 class="code-header">pub fn <a href="#method.from_element" class="fn">from_element</a>(elem: T) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Constructs a new bit-vector from a single element.</p>
<p>This copies <code>elem</code> into a new heap allocation, and sets the bit-vector
to cover it entirely.</p>
<h6 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = BitVec::&lt;<span class="kw">_</span>, Msb0&gt;::from_element(<span class="number">1u8</span>);
<span class="macro">assert!</span>(bv[<span class="number">7</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice" class="method"><h4 class="code-header">pub fn <a href="#method.from_slice" class="fn">from_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Constructs a new bit-vector from a slice of memory elements.</p>
<p>This copies <code>slice</code> into a new heap allocation, and sets the bit-vector
to cover it entirely.</p>
<h6 id="panics-12"><a class="doc-anchor" href="#panics-12">§</a>Panics</h6>
<p>This panics if <code>slice</code> exceeds bit-vector capacity.</p>
<h6 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="kw-2">&amp;</span>[<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>bv = BitVec::&lt;<span class="kw">_</span>, Lsb0&gt;::from_slice(slice);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">32</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_slice" class="method"><h4 class="code-header">pub fn <a href="#method.try_from_slice" class="fn">try_from_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;, BitSpanError&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Fallibly constructs a new bit-vector from a slice of memory elements.</p>
<p>This fails early if <code>slice</code> exceeds bit-vector capacity. If it is not,
then <code>slice</code> is copied into a new heap allocation and fully spanned by
the returned bit-vector.</p>
<h6 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="kw-2">&amp;</span>[<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>bv = BitVec::&lt;<span class="kw">_</span>, Lsb0&gt;::try_from_slice(slice).unwrap();
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">32</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec" class="method"><h4 class="code-header">pub fn <a href="#method.from_vec" class="fn">from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Converts a regular vector in-place into a bit-vector.</p>
<p>The produced bit-vector spans every bit in the original vector. No
reällocation occurs; this is purely a transform of the handle.</p>
<h6 id="panics-13"><a class="doc-anchor" href="#panics-13">§</a>Panics</h6>
<p>This panics if the source vector is too long to view as a bit-slice.</p>
<h6 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>bv = BitVec::&lt;<span class="kw">_</span>, Msb0&gt;::from_vec(v);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">32</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_vec" class="method"><h4 class="code-header">pub fn <a href="#method.try_from_vec" class="fn">try_from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to convert a regular vector in-place into a bit-vector.</p>
<p>This fails if the source vector is too long to view as a bit-slice. On
success, the produced bit-vector spans every bit in the original vector.
No reällocation occurs; this is purely a transform of the handle.</p>
<h6 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="number">20</span>];
<span class="macro">assert_eq!</span>(BitVec::&lt;<span class="kw">_</span>, Msb0&gt;::try_from_vec(v).unwrap().len(), <span class="number">160</span>);</code></pre></div>
<p>It is not practical to allocate a vector that will fail this conversion.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_from_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.extend_from_bitslice" class="fn">extend_from_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Appends the contents of a bit-slice to a bit-vector.</p>
<p>This can extend from a bit-slice of any type parameters; it is not
restricted to using the same parameters as <code>self</code>. However, when the
type parameters <em>do</em> match, it is possible for this to use a batch-copy
optimization to go faster than the individual-bit crawl that is
necessary when they differ.</p>
<p>Until Rust provides extensive support for specialization in trait
implementations, you should use this method whenever you are extending
from a <code>BitSlice</code> proper, and only use the general <a href="https://docs.rs/bitvec/latest/bitvec/vec/struct.Vec.html#impl-Extend"><code>.extend()</code></a>
implementation if you are required to use a generic <code>bool</code> source.</p>
<h6 id="original-28"><a class="doc-anchor" href="#original-28">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.extend_from_slice" title="method alloc::vec::Vec::extend_from_slice"><code>Vec::extend_from_slice</code></a></p>
<h6 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>];
bv.extend_from_bitslice(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_from_raw_slice" class="method"><h4 class="code-header">pub fn <a href="#method.extend_from_raw_slice" class="fn">extend_from_raw_slice</a>(&amp;mut self, slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a>)</h4></section></summary><div class="docblock"><p>Appends a slice of <code>T</code> elements to a bit-vector.</p>
<p>The slice is viewed as a <code>BitSlice&lt;T, O&gt;</code>, then appended directly to the
bit-vector.</p>
<h6 id="original-29"><a class="doc-anchor" href="#original-29">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.extend_from_slice" title="method alloc::vec::Vec::extend_from_slice"><code>Vec::extend_from_slice</code></a></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CT,+O%3E-2" class="impl"><a href="#impl-BitVec%3CT,+O%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><p>Converters.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitslice" class="fn">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Explicitly views the bit-vector as a bit-slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_bitslice" class="fn">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Explicitly views the bit-vector as a mutable bit-slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_raw_slice" class="method"><h4 class="code-header">pub fn <a href="#method.as_raw_slice" class="fn">as_raw_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Views the bit-vector as a slice of its underlying memory elements.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_raw_mut_slice" class="method"><h4 class="code-header">pub fn <a href="#method.as_raw_mut_slice" class="fn">as_raw_mut_slice</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Views the bit-vector as a mutable slice of its underlying memory
elements.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fn">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Creates an unsafe shared bit-pointer to the start of the buffer.</p>
<h6 id="original-30"><a class="doc-anchor" href="#original-30">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.as_ptr" title="method alloc::vec::Vec::as_ptr"><code>Vec::as_ptr</code></a></p>
<h6 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h6>
<p>You must initialize the contents of the underlying buffer before
accessing memory through this pointer. See the <code>BitPtr</code> documentation
for more details.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr" class="fn">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;</h4></section></summary><div class="docblock"><p>Creates an unsafe writable bit-pointer to the start of the buffer.</p>
<h6 id="original-31"><a class="doc-anchor" href="#original-31">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.as_mut_ptr" title="method alloc::vec::Vec::as_mut_ptr"><code>Vec::as_mut_ptr</code></a></p>
<h6 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h6>
<p>You must initialize the contents of the underlying buffer before
accessing memory through this pointer. See the <code>BitPtr</code> documentation
for more details.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_boxed_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.into_boxed_bitslice" class="fn">into_boxed_bitslice</a>(self) -&gt; <a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class="docblock"><p>Converts a bit-vector into a boxed bit-slice.</p>
<p>This may cause a reällocation to drop any excess capacity.</p>
<h6 id="original-32"><a class="doc-anchor" href="#original-32">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.into_boxed_slice" title="method alloc::vec::Vec::into_boxed_slice"><code>Vec::into_boxed_slice</code></a></p>
<h6 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bb = bv.into_boxed_bitslice();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_vec" class="method"><h4 class="code-header">pub fn <a href="#method.into_vec" class="fn">into_vec</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Converts a bit-vector into a <code>Vec</code> of its underlying storage.</p>
<p>The produced vector contains all elements that contained live bits. Dead
bits have an unspecified value; you should call <a href="struct.BitVec.html#method.set_uninitialized" title="method common_base::bit_vec::prelude::BitVec::set_uninitialized"><code>.set_uninitialized()</code></a>
before converting into a vector.</p>
<p>This does not affect the allocated memory; it is purely a conversion of
the handle.</p>
<h6 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[u8, Msb0; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>v = bv.into_vec();
<span class="macro">assert_eq!</span>(v[<span class="number">0</span>] &amp; <span class="number">0xF8</span>, <span class="number">0b01001_000</span>);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitVec%3CT,+O%3E-3" class="impl"><a href="#impl-BitVec%3CT,+O%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><p>Utilities.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set_elements" class="method"><h4 class="code-header">pub fn <a href="#method.set_elements" class="fn">set_elements</a>(&amp;mut self, element: &lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Mem" title="type common_base::bit_vec::prelude::BitStore::Mem">Mem</a>)</h4></section></summary><div class="docblock"><p>Overwrites each element (visible in <a href="struct.BitVec.html#method.as_raw_mut_slice" title="method common_base::bit_vec::prelude::BitVec::as_raw_mut_slice"><code>.as_raw_mut_slice()</code></a>) with a new
bit-pattern.</p>
<p>This unconditionally writes <code>element</code> into each element in the backing
slice, without altering the bit-vector’s length or capacity.</p>
<p>This guarantees that dead bits visible in <a href="struct.BitVec.html#method.as_raw_slice" title="method common_base::bit_vec::prelude::BitVec::as_raw_slice"><code>.as_raw_slice()</code></a> but not
<a href="struct.BitVec.html#method.as_bitslice" title="method common_base::bit_vec::prelude::BitVec::as_bitslice"><code>.as_bitslice()</code></a> are initialized according to the bit-pattern of
<code>element.</code> The elements not visible in the raw slice, but present in the
allocation, do <em>not</em> specify a value. You may not rely on them being
zeroed <em>or</em> being set to the <code>element</code> bit-pattern.</p>
<h6 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>element</code>: The bit-pattern with which each live element in the backing
store is initialized.</li>
</ul>
<h6 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[u8, Msb0; <span class="number">0</span>; <span class="number">20</span>];
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), [<span class="number">0</span>; <span class="number">3</span>]);
bv.set_elements(<span class="number">0xA5</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), [<span class="number">0xA5</span>; <span class="number">3</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_uninitialized" class="method"><h4 class="code-header">pub fn <a href="#method.set_uninitialized" class="fn">set_uninitialized</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the uninitialized bits of a bit-vector to a known value.</p>
<p>This method modifies all bits that are observable in <a href="struct.BitVec.html#method.as_raw_slice" title="method common_base::bit_vec::prelude::BitVec::as_raw_slice"><code>.as_raw_slice()</code></a>
but <em>not</em> observable in <a href="struct.BitVec.html#method.as_bitslice" title="method common_base::bit_vec::prelude::BitVec::as_bitslice"><code>.as_bitslice()</code></a> to a known value.
Memory beyond the raw-slice view, but still within the allocation, is
considered fully dead and will never be seen.</p>
<p>This can be used to zero the unused memory so that when viewed as a raw
slice, unused bits have a consistent and predictable value.</p>
<h6 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="number">0b1101_1100u8</span>.view_bits::&lt;Lsb0&gt;().to_bitvec();
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], <span class="number">0b1101_1100u8</span>);

bv.truncate(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(bv.count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], <span class="number">0b1101_1100u8</span>);

bv.set_uninitialized(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], <span class="number">0b0000_1100u8</span>);

bv.set_uninitialized(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], <span class="number">0b1111_1100u8</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.force_align" class="method"><h4 class="code-header">pub fn <a href="#method.force_align" class="fn">force_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Ensures that the live region of the bit-vector’s contents begin at the
front edge of the buffer.</p>
<p><code>BitVec</code> has performance optimizations where it moves its view of its
buffer contents in order to avoid needless moves of its data within the
buffer. This can lead to unexpected contents of the raw memory values,
so this method ensures that the semantic contents of the bit-vector
match its in-memory storage.</p>
<h6 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b00_1111_00u8</span>;
<span class="kw">let </span>bits = data.view_bits::&lt;Msb0&gt;();

<span class="kw">let </span><span class="kw-2">mut </span>bv = bits[<span class="number">2 </span>.. <span class="number">6</span>].to_bitvec();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], data);

bv.force_align();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">4</span>]);
<span class="comment">// BitVec does not specify the value of dead bits in its buffer.
</span><span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>] &amp; <span class="number">0xF0</span>, <span class="number">0xF0</span>);</code></pre></div></div></details></div></details></div><details class="toggle big-toggle" open><summary><h2 id="deref-methods-BitSlice%3CT,+O%3E" class="section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;</span><a href="#deref-methods-BitSlice%3CT,+O%3E" class="anchor">§</a></h2></summary><div id="deref-methods-BitSlice%3CT,+O%3E-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len-1" class="method"><h4 class="code-header">pub fn <a href="#method.len-1" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of bits in the bit-slice.</p>
<h6 id="original-33"><a class="doc-anchor" href="#original-33">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h6 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].len(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].len(), <span class="number">10</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty-1" class="method"><h4 class="code-header">pub fn <a href="#method.is_empty-1" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if the bit-slice is empty (length zero).</p>
<h6 id="original-34"><a class="doc-anchor" href="#original-34">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h6 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].is_empty());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].is_empty());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the first bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-35"><a class="doc-anchor" href="#original-35">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h6 id="api-differences-5"><a class="doc-anchor" href="#api-differences-5">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.first().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first_mut" class="method"><h4 class="code-header">pub fn <a href="#method.first_mut" class="fn">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Mut, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the first bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-36"><a class="doc-anchor" href="#original-36">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h6 id="api-differences-6"><a class="doc-anchor" href="#api-differences-6">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>first) = bits.first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].first_mut().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_first" class="method"><h4 class="code-header">pub fn <a href="#method.split_first" class="fn">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Const, T, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its first bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-37"><a class="doc-anchor" href="#original-37">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first"><code>slice::split_first</code></a></p>
<h6 id="api-differences-7"><a class="doc-anchor" href="#api-differences-7">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span>(first, rest) = bits.split_first().unwrap();
<span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_first_mut" class="method"><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fn">split_first_mut</a>(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Mut, &lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references of its first bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-38"><a class="doc-anchor" href="#original-38">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>slice::split_first_mut</code></a></p>
<h6 id="api-differences-8"><a class="doc-anchor" href="#api-differences-8">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>first, rest)) = bits.split_first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_last" class="method"><h4 class="code-header">pub fn <a href="#method.split_last" class="fn">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Const, T, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its last bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-39"><a class="doc-anchor" href="#original-39">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h6 id="api-differences-9"><a class="doc-anchor" href="#api-differences-9">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>(last, rest) = bits.split_last().unwrap();
<span class="macro">assert_eq!</span>(last, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_last_mut" class="method"><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fn">split_last_mut</a>(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Mut, &lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references to its last bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-40"><a class="doc-anchor" href="#original-40">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h6 id="api-differences-10"><a class="doc-anchor" href="#api-differences-10">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-43"><a class="doc-anchor" href="#examples-43">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>last, rest)) = bits.split_last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the last bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-41"><a class="doc-anchor" href="#original-41">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h6 id="api-differences-11"><a class="doc-anchor" href="#api-differences-11">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-44"><a class="doc-anchor" href="#examples-44">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bits.last().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last_mut" class="method"><h4 class="code-header">pub fn <a href="#method.last_mut" class="fn">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'_, Mut, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the last bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-42"><a class="doc-anchor" href="#original-42">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h6 id="api-differences-12"><a class="doc-anchor" href="#api-differences-12">§</a>API Differences</h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-45"><a class="doc-anchor" href="#examples-45">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>last) = bits.last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].last_mut().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;'a, I&gt;(
    &amp;'a self,
    index: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Immut&gt;<div class="where">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</div></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or a subsection of the bit-slice,
depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-43"><a class="doc-anchor" href="#original-43">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h6 id="api-differences-13"><a class="doc-anchor" href="#api-differences-13">§</a>API Differences</h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-46"><a class="doc-anchor" href="#examples-46">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.get(<span class="number">1</span>).as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bits.get(<span class="number">0 </span>.. <span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(bits.get(<span class="number">3</span>).is_none());
<span class="macro">assert!</span>(bits.get(<span class="number">0 </span>.. <span class="number">4</span>).is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;'a, I&gt;(
    &amp;'a mut self,
    index: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Mut&gt;<div class="where">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</div></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-44"><a class="doc-anchor" href="#original-44">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h6 id="api-differences-14"><a class="doc-anchor" href="#api-differences-14">§</a>API Differences</h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-47"><a class="doc-anchor" href="#examples-47">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];

<span class="kw-2">*</span>bits.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
bits.get_mut(<span class="number">1 </span>..).unwrap().fill(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;'a, I&gt;(
    &amp;'a self,
    index: I,
) -&gt; &lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Immut<div class="where">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</div></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or to a subsection of the bit-slice,
without bounds checking.</p>
<p>This has the same arguments and behavior as <a href="struct.BitSlice.html#method.get" title="method common_base::bit_vec::prelude::BitSlice::get"><code>.get()</code></a>, except that it
does not check that <code>index</code> is in bounds.</p>
<h6 id="original-45"><a class="doc-anchor" href="#original-45">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h6 id="safety-5"><a class="doc-anchor" href="#safety-5">§</a>Safety</h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-48"><a class="doc-anchor" href="#examples-48">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0001_0010u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">3</span>];

<span class="kw">unsafe </span>{
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">1</span>));
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">4</span>));
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;'a, I&gt;(
    &amp;'a mut self,
    index: I,
) -&gt; &lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Mut<div class="where">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</div></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<p>This has the same arguments and behavior as <a href="struct.BitSlice.html#method.get_mut" title="method common_base::bit_vec::prelude::BitSlice::get_mut"><code>.get_mut()</code></a>, except that
it does not check that <code>index</code> is in bounds.</p>
<h6 id="original-46"><a class="doc-anchor" href="#original-46">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h6 id="safety-6"><a class="doc-anchor" href="#safety-6">§</a>Safety</h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-49"><a class="doc-anchor" href="#examples-49">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;mut </span>data.view_bits_mut::&lt;Lsb0&gt;()[.. <span class="number">3</span>];

<span class="kw">unsafe </span>{
  bits.get_unchecked_mut(<span class="number">1</span>).commit(<span class="bool-val">true</span>);
  bits.get_unchecked_mut(<span class="number">4 </span>.. <span class="number">6</span>).fill(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">0b0011_0010</span>);</code></pre></div></div></details><section id="method.as_ptr-1" class="method"><h4 class="code-header">pub fn <a href="#method.as_ptr-1" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Const, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_bitptr()</code> instead</span></div></span><section id="method.as_mut_ptr-1" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_ptr-1" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_mut_bitptr()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.as_ptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_ptr_range" class="fn">as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="struct.BitSlice.html#method.as_bitptr_range" title="method common_base::bit_vec::prelude::BitSlice::as_bitptr_range"><code>.as_bitptr_range()</code></a> instead, as it
produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-47"><a class="doc-anchor" href="#original-47">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_ptr_range" class="fn">as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of mutable bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="struct.BitSlice.html#method.as_mut_bitptr_range" title="method common_base::bit_vec::prelude::BitSlice::as_mut_bitptr_range"><code>.as_mut_bitptr_range()</code></a> instead, as
it produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-48"><a class="doc-anchor" href="#original-48">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap" class="method"><h4 class="code-header">pub fn <a href="#method.swap" class="fn">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Exchanges the bit values at two indices.</p>
<h6 id="original-49"><a class="doc-anchor" href="#original-49">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h6 id="panics-14"><a class="doc-anchor" href="#panics-14">§</a>Panics</h6>
<p>This panics if either <code>a</code> or <code>b</code> are out of bounds.</p>
<h6 id="examples-50"><a class="doc-anchor" href="#examples-50">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>];
bits.swap(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reverse" class="method"><h4 class="code-header">pub fn <a href="#method.reverse" class="fn">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in a bit-slice.</p>
<h6 id="original-50"><a class="doc-anchor" href="#original-50">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h6 id="examples-51"><a class="doc-anchor" href="#examples-51">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bits.reverse();
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; Iter&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Produces an iterator over each bit in the bit-slice.</p>
<h6 id="original-51"><a class="doc-anchor" href="#original-51">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h6 id="api-differences-15"><a class="doc-anchor" href="#api-differences-15">§</a>API Differences</h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;bool</code>. It can be
adapted to yield <code>&amp;bool</code> with the <a href="crate::slice::Iter::by_refs"><code>.by_refs()</code></a> method, or <code>bool</code> with
<a href="crate::slice::Iter::by_vals"><code>.by_vals()</code></a>.</p>
<p>This iterator, and its adapters, are fast. Do not try to be more clever
than them by abusing <code>.as_bitptr_range()</code>.</p>
<h6 id="examples-52"><a class="doc-anchor" href="#examples-52">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.iter();

<span class="macro">assert!</span>(!iter.next().unwrap());
<span class="macro">assert!</span>( iter.next().unwrap());
<span class="macro">assert!</span>( iter.next_back().unwrap());
<span class="macro">assert!</span>(!iter.next_back().unwrap());
<span class="macro">assert!</span>( iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iter_mut" class="method"><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fn">iter_mut</a>(&amp;mut self) -&gt; IterMut&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Produces a mutable iterator over each bit in the bit-slice.</p>
<h6 id="original-52"><a class="doc-anchor" href="#original-52">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>slice::iter_mut</code></a></p>
<h6 id="api-differences-16"><a class="doc-anchor" href="#api-differences-16">§</a>API Differences</h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;mut bool</code>. In
addition, it marks each proxy as alias-tainted.</p>
<p>If you are using this in an ordinary loop and <strong>not</strong> keeping multiple
yielded proxy-references alive at the same scope, you may use the
<a href="crate::slice::IterMut::remove_alias"><code>.remove_alias()</code></a> adapter to undo the alias marking.</p>
<p>This iterator is fast. Do not try to be more clever than it by abusing
<code>.as_mut_bitptr_range()</code>.</p>
<h6 id="examples-53"><a class="doc-anchor" href="#examples-53">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">4</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.iter_mut();

iter.nth(<span class="number">1</span>).unwrap().commit(<span class="bool-val">true</span>); <span class="comment">// index 1
</span>iter.next_back().unwrap().commit(<span class="bool-val">true</span>); <span class="comment">// index 3

</span><span class="macro">assert!</span>(iter.next().is_some()); <span class="comment">// index 2
</span><span class="macro">assert!</span>(iter.next().is_none()); <span class="comment">// complete
</span><span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.windows" class="method"><h4 class="code-header">pub fn <a href="#method.windows" class="fn">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Windows&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over consecutive windowing subslices in a bit-slice.</p>
<p>Windows are overlapping views of the bit-slice. Each window advances one
bit from the previous, so in a bit-slice <code>[A, B, C, D, E]</code>, calling
<code>.windows(3)</code> will yield <code>[A, B, C]</code>, <code>[B, C, D]</code>, and <code>[C, D, E]</code>.</p>
<h6 id="original-53"><a class="doc-anchor" href="#original-53">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h6 id="panics-15"><a class="doc-anchor" href="#panics-15">§</a>Panics</h6>
<p>This panics if <code>size</code> is <code>0</code>.</p>
<h6 id="examples-54"><a class="doc-anchor" href="#examples-54">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.windows(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chunks" class="method"><h4 class="code-header">pub fn <a href="#method.chunks" class="fn">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Chunks&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>Unlike <code>.windows()</code>, the subslices this yields do not overlap with each
other. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
last chunk yielded will be shorter.</p>
<h6 id="original-54"><a class="doc-anchor" href="#original-54">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h6 id="sibling-methods"><a class="doc-anchor" href="#sibling-methods">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_mut"><code>.chunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact"><code>.chunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.rchunks" title="method common_base::bit_vec::prelude::BitSlice::rchunks"><code>.rchunks()</code></a> iterates from the back of the bit-slice to the front,
with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-16"><a class="doc-anchor" href="#panics-16">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-55"><a class="doc-anchor" href="#examples-55">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_mut" class="method"><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fn">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; ChunksMut&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::ChunksMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-55"><a class="doc-anchor" href="#original-55">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h6 id="sibling-methods-1"><a class="doc-anchor" href="#sibling-methods-1">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks" title="method common_base::bit_vec::prelude::BitSlice::chunks"><code>.chunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact_mut"><code>.chunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.rchunks_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_mut"><code>.rchunks_mut()</code></a> iterates from the back of the bit-slice to the
front, with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-17"><a class="doc-anchor" href="#panics-17">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-56"><a class="doc-anchor" href="#examples-56">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for </span>(idx, chunk) <span class="kw">in unsafe </span>{
  bits.chunks_mut(<span class="number">2</span>).remove_alias()
}.enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                     ^^^^  ^^^^  ^</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_exact" class="method"><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fn">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; ChunksExact&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::ChunksExact::remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-56"><a class="doc-anchor" href="#original-56">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h6 id="sibling-methods-2"><a class="doc-anchor" href="#sibling-methods-2">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks" title="method common_base::bit_vec::prelude::BitSlice::chunks"><code>.chunks()</code></a> yields any leftover bits at the end as a shorter chunk
during iteration.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact_mut"><code>.chunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact"><code>.rchunks_exact()</code></a> iterates from the back of the bit-slice to the
front, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-18"><a class="doc-anchor" href="#panics-18">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-57"><a class="doc-anchor" href="#examples-57">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method"><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fn">chunks_exact_mut</a>(
    &amp;mut self,
    chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; ChunksExactMut&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::ChunksExactMut::into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::ChunksExactMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-57"><a class="doc-anchor" href="#original-57">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h6 id="sibling-methods-3"><a class="doc-anchor" href="#sibling-methods-3">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_mut"><code>.chunks_mut()</code></a> yields any leftover bits at the end as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact"><code>.chunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> iterates from the back of the bit-slice
forwards, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-19"><a class="doc-anchor" href="#panics-19">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-58"><a class="doc-anchor" href="#examples-58">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact_mut(<span class="number">2</span>);

<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>iter.by_ref().enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
iter.into_remainder().store(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                       remainder ^</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks" class="fn">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; RChunks&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>Unlike <code>.chunks()</code>, this aligns its chunks to the back edge of <code>self</code>.
If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<h6 id="original-58"><a class="doc-anchor" href="#original-58">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h6 id="sibling-methods-4"><a class="doc-anchor" href="#sibling-methods-4">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_mut"><code>.rchunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact"><code>.rchunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.chunks" title="method common_base::bit_vec::prelude::BitSlice::chunks"><code>.chunks()</code></a> iterates from the front of the bit-slice to the back,
with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="panics-20"><a class="doc-anchor" href="#panics-20">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-59"><a class="doc-anchor" href="#examples-59">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fn">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; RChunksMut&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>Unlike <code>.chunks_mut()</code>, this aligns its chunks to the back edge of
<code>self</code>. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then
the leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded values for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::RChunksMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-59"><a class="doc-anchor" href="#original-59">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h6 id="sibling-methods-5"><a class="doc-anchor" href="#sibling-methods-5">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks" title="method common_base::bit_vec::prelude::BitSlice::rchunks"><code>.rchunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.chunks_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_mut"><code>.chunks_mut()</code></a> iterates from the front of the bit-slice to the
back, with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="examples-60"><a class="doc-anchor" href="#examples-60">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in unsafe </span>{
  bits.rchunks_mut(<span class="number">2</span>).remove_alias()
}.enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^  ^^^^  ^^^^</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fn">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; RChunksExact&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::RChunksExact::remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-60"><a class="doc-anchor" href="#original-60">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h6 id="sibling-methods-6"><a class="doc-anchor" href="#sibling-methods-6">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks" title="method common_base::bit_vec::prelude::BitSlice::rchunks"><code>.rchunks()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact"><code>.chunks_exact()</code></a> iterates from the front of the bit-slice to the
back, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-21"><a class="doc-anchor" href="#panics-21">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-61"><a class="doc-anchor" href="#examples-61">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fn">rchunks_exact_mut</a>(
    &amp;mut self,
    chunk_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; RChunksExactMut&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::RChunksExactMut::into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::RChunksExactMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="sibling-methods-7"><a class="doc-anchor" href="#sibling-methods-7">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks_mut" title="method common_base::bit_vec::prelude::BitSlice::rchunks_mut"><code>.rchunks_mut()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact" title="method common_base::bit_vec::prelude::BitSlice::rchunks_exact"><code>.rchunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut" title="method common_base::bit_vec::prelude::BitSlice::chunks_exact_mut"><code>.chunks_exact_mut()</code></a> iterates from the front of the bit-slice
backwards, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-22"><a class="doc-anchor" href="#panics-22">§</a>Panics</h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-62"><a class="doc-anchor" href="#examples-62">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact_mut(<span class="number">2</span>);

<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>iter.by_ref().enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
iter.into_remainder().store(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-61"><a class="doc-anchor" href="#original-61">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h6 id="panics-23"><a class="doc-anchor" href="#panics-23">§</a>Panics</h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-63"><a class="doc-anchor" href="#examples-63">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>base = bits.as_bitptr();

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ a.as_bitptr().offset_from(base) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">0</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">6</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(b, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(
    &amp;mut self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; (&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-62"><a class="doc-anchor" href="#original-62">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h6 id="api-differences-17"><a class="doc-anchor" href="#api-differences-17">§</a>API Differences</h6>
<p>The end bits of the left half and the start bits of the right half might
be stored in the same memory element. In order to avoid breaking
<code>bitvec</code>’s memory-safety guarantees, both bit-slices are marked as
<code>T::Alias</code>. This marking allows them to be used without interfering with
each other when they interact with memory.</p>
<h6 id="panics-24"><a class="doc-anchor" href="#panics-24">§</a>Panics</h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-64"><a class="doc-anchor" href="#examples-64">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let </span>base = bits.as_mut_bitptr();

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ a.as_mut_bitptr().offset_from(base) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_mut_bitptr().offset_from(base) }, <span class="number">0</span>);

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_mut_bitptr().offset_from(base) }, <span class="number">6</span>);

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">3</span>);
a.store(<span class="number">3</span>);
b.store(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; Split&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. The
matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<h6 id="original-63"><a class="doc-anchor" href="#original-63">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h6 id="api-differences-18"><a class="doc-anchor" href="#api-differences-18">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-8"><a class="doc-anchor" href="#sibling-methods-8">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_mut" title="method common_base::bit_vec::prelude::BitSlice::split_mut"><code>.split_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split_inclusive" title="method common_base::bit_vec::prelude::BitSlice::split_inclusive"><code>.split_inclusive()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="struct.BitSlice.html#method.rsplit" title="method common_base::bit_vec::prelude::BitSlice::rsplit"><code>.rsplit()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="struct.BitSlice.html#method.splitn" title="method common_base::bit_vec::prelude::BitSlice::splitn"><code>.splitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-65"><a class="doc-anchor" href="#examples-65">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the first bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the last bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two matched bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_mut" class="method"><h4 class="code-header">pub fn <a href="#method.split_mut" class="fn">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; SplitMut&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. The matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::SplitMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-64"><a class="doc-anchor" href="#original-64">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h6 id="api-differences-19"><a class="doc-anchor" href="#api-differences-19">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-9"><a class="doc-anchor" href="#sibling-methods-9">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.split" title="method common_base::bit_vec::prelude::BitSlice::split"><code>.split()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_inclusive_mut" title="method common_base::bit_vec::prelude::BitSlice::split_inclusive_mut"><code>.split_inclusive_mut()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="struct.BitSlice.html#method.rsplit_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplit_mut"><code>.rsplit_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="struct.BitSlice.html#method.splitn_mut" title="method common_base::bit_vec::prelude::BitSlice::splitn_mut"><code>.splitn_mut()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-66"><a class="doc-anchor" href="#examples-66">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.split_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; SplitInclusive&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. Unlike
<code>.split()</code>, this <em>does</em> include the matching bit as the last bit in the
yielded bit-slice.</p>
<h6 id="original-65"><a class="doc-anchor" href="#original-65">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive"><code>slice::split_inclusive</code></a></p>
<h6 id="api-differences-20"><a class="doc-anchor" href="#api-differences-20">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-10"><a class="doc-anchor" href="#sibling-methods-10">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_inclusive_mut" title="method common_base::bit_vec::prelude::BitSlice::split_inclusive_mut"><code>.split_inclusive_mut()</code></a> has the same splitting logic, but each
yielded bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split" title="method common_base::bit_vec::prelude::BitSlice::split"><code>.split()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-67"><a class="doc-anchor" href="#examples-67">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split_inclusive(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive_mut" class="method"><h4 class="code-header">pub fn <a href="#method.split_inclusive_mut" class="fn">split_inclusive_mut</a>&lt;F&gt;(
    &amp;mut self,
    pred: F,
) -&gt; SplitInclusiveMut&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. Unlike <code>.split_mut()</code>, this <em>does</em> include the matching bit
as the last bit in the bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::SplitInclusiveMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-66"><a class="doc-anchor" href="#original-66">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive_mut"><code>slice::split_inclusive_mut</code></a></p>
<h6 id="api-differences-21"><a class="doc-anchor" href="#api-differences-21">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-11"><a class="doc-anchor" href="#sibling-methods-11">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_inclusive" title="method common_base::bit_vec::prelude::BitSlice::split_inclusive"><code>.split_inclusive()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_mut" title="method common_base::bit_vec::prelude::BitSlice::split_mut"><code>.split_mut()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-68"><a class="doc-anchor" href="#examples-68">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="comment">//                         ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.split_inclusive_mut(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; RSplit&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, from
the back edge. The matched bit is <em>not</em> contained in the yielded
bit-slices.</p>
<h6 id="original-67"><a class="doc-anchor" href="#original-67">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h6 id="api-differences-22"><a class="doc-anchor" href="#api-differences-22">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-12"><a class="doc-anchor" href="#sibling-methods-12">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplit_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split" title="method common_base::bit_vec::prelude::BitSlice::split"><code>.split()</code></a> iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="struct.BitSlice.html#method.rsplitn" title="method common_base::bit_vec::prelude::BitSlice::rsplitn"><code>.rsplitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-69"><a class="doc-anchor" href="#examples-69">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the last bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the first bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two yielded bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method"><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fn">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; RSplitMut&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, from the back. The matched bit is <em>not</em> contained in the
yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::RSplitMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-68"><a class="doc-anchor" href="#original-68">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h6 id="api-differences-23"><a class="doc-anchor" href="#api-differences-23">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-13"><a class="doc-anchor" href="#sibling-methods-13">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplit" title="method common_base::bit_vec::prelude::BitSlice::rsplit"><code>.rsplit()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_mut" title="method common_base::bit_vec::prelude::BitSlice::split_mut"><code>.split_mut()</code></a> iterates from the front of the bit-slice to the back.</li>
<li><a href="struct.BitSlice.html#method.rsplitn_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the front of the bit-slice to the
back.</li>
</ul>
<h6 id="examples-70"><a class="doc-anchor" href="#examples-70">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.rsplit_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pred: F) -&gt; SplitN&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, giving
up after yielding <code>n</code> times. The <code>n</code>th yield contains the rest of the
bit-slice. As with <code>.split()</code>, the yielded bit-slices do not contain the
matched bit.</p>
<h6 id="original-69"><a class="doc-anchor" href="#original-69">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h6 id="api-differences-24"><a class="doc-anchor" href="#api-differences-24">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-14"><a class="doc-anchor" href="#sibling-methods-14">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.splitn_mut" title="method common_base::bit_vec::prelude::BitSlice::splitn_mut"><code>.splitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rsplitn" title="method common_base::bit_vec::prelude::BitSlice::rsplitn"><code>.rsplitn()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="struct.BitSlice.html#method.split" title="method common_base::bit_vec::prelude::BitSlice::split"><code>.split()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-71"><a class="doc-anchor" href="#examples-71">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.splitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.splitn_mut" class="method"><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fn">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pred: F) -&gt; SplitNMut&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, giving up after yielding <code>n</code> times. The <code>n</code>th yield contains
the rest of the bit-slice. As with <code>.split_mut()</code>, the yielded
bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::SplitNMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-70"><a class="doc-anchor" href="#original-70">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h6 id="api-differences-25"><a class="doc-anchor" href="#api-differences-25">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-15"><a class="doc-anchor" href="#sibling-methods-15">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.splitn" title="method common_base::bit_vec::prelude::BitSlice::splitn"><code>.splitn()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.rsplitn_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="struct.BitSlice.html#method.split_mut" title="method common_base::bit_vec::prelude::BitSlice::split_mut"><code>.split_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-72"><a class="doc-anchor" href="#examples-72">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.splitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pred: F) -&gt; RSplitN&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<h6 id="original-71"><a class="doc-anchor" href="#original-71">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h6 id="api-differences-26"><a class="doc-anchor" href="#api-differences-26">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-16"><a class="doc-anchor" href="#sibling-methods-16">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplitn_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplitn_mut"><code>.rsplitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.splitn" title="method common_base::bit_vec::prelude::BitSlice::splitn"><code>.splitn()</code></a>: iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="struct.BitSlice.html#method.rsplit" title="method common_base::bit_vec::prelude::BitSlice::rsplit"><code>.rsplit()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-73"><a class="doc-anchor" href="#examples-73">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                        ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method"><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fn">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pred: F) -&gt; RSplitNMut&lt;'_, T, O, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="crate::slice::RSplitNMut::remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-72"><a class="doc-anchor" href="#original-72">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h6 id="api-differences-27"><a class="doc-anchor" href="#api-differences-27">§</a>API Differences</h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-17"><a class="doc-anchor" href="#sibling-methods-17">§</a>Sibling Methods</h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplitn" title="method common_base::bit_vec::prelude::BitSlice::rsplitn"><code>.rsplitn()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.splitn_mut" title="method common_base::bit_vec::prelude::BitSlice::splitn_mut"><code>.splitn_mut()</code></a> iterates from the front of the bit-slice instead of
the back.</li>
<li><a href="struct.BitSlice.html#method.rsplit_mut" title="method common_base::bit_vec::prelude::BitSlice::rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-74"><a class="doc-anchor" href="#examples-74">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.rsplitn_mut(<span class="number">2</span>, |_idx, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">//                     ^ group 2         ^ group 1</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;T2, O2&gt;(&amp;self, other: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Tests if the bit-slice contains the given sequence anywhere within it.</p>
<p>This scans over <code>self.windows(other.len())</code> until one of the windows
matches. The search key does not need to share type parameters with the
bit-slice being tested, as the comparison is bit-wise. However, sharing
type parameters will accelerate the comparison.</p>
<h6 id="original-73"><a class="doc-anchor" href="#original-73">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h6 id="examples-75"><a class="doc-anchor" href="#examples-75">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.contains(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.contains(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Tests if the bit-slice begins with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-74"><a class="doc-anchor" href="#original-74">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h6 id="examples-76"><a class="doc-anchor" href="#examples-76">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.starts_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(!bits.starts_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.starts_with(empty));
<span class="macro">assert!</span>(empty.starts_with(empty));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Tests if the bit-slice ends with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-75"><a class="doc-anchor" href="#original-75">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h6 id="examples-77"><a class="doc-anchor" href="#examples-77">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.ends_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.ends_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.ends_with(empty));
<span class="macro">assert!</span>(empty.ends_with(empty));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;T2, O2&gt;(
    &amp;self,
    prefix: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Removes a prefix bit-slice, if present.</p>
<p>Like <a href="struct.BitSlice.html#method.starts_with" title="method common_base::bit_vec::prelude::BitSlice::starts_with"><code>.starts_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.starts_with(suffix)</code>, then this returns <code>Some(&amp;self[prefix.len() ..])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-76"><a class="doc-anchor" href="#original-76">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_prefix"><code>slice::strip_prefix</code></a></p>
<h6 id="api-differences-28"><a class="doc-anchor" href="#api-differences-28">§</a>API Differences</h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>prefix</code> to differ in type parameters.</p>
<h6 id="examples-78"><a class="doc-anchor" href="#examples-78">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).unwrap(), bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,]).unwrap(), bits[<span class="number">4 </span>..]);
<span class="macro">assert!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;T2, O2&gt;(
    &amp;self,
    suffix: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Removes a suffix bit-slice, if present.</p>
<p>Like <a href="Self::ends_with."><code>.ends_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.ends_with(suffix)</code>, then this returns <code>Some(&amp;self[.. self.len() - suffix.len()])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-77"><a class="doc-anchor" href="#original-77">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_suffix"><code>slice::strip_suffix</code></a></p>
<h6 id="api-differences-29"><a class="doc-anchor" href="#api-differences-29">§</a>API Differences</h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>suffix</code> to differ in type parameters.</p>
<h6 id="examples-79"><a class="doc-anchor" href="#examples-79">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">5</span>]);
<span class="macro">assert!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).is_none());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_left" class="method"><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fn">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the left (towards the zero
index).</p>
<p>This essentially splits the bit-slice at <code>by</code>, then exchanges the two
pieces. <code>self[.. by]</code> becomes the first section, and is then followed by
<code>self[.. by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-78"><a class="doc-anchor" href="#original-78">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_left"><code>slice::rotate_left</code></a></p>
<h6 id="examples-80"><a class="doc-anchor" href="#examples-80">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//      split occurs here ^
</span>bits.rotate_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_right" class="method"><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fn">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the right (away from the zero
index).</p>
<p>This essentially splits the bit-slice at <code>self.len() - by</code>, then
exchanges the two pieces. <code>self[len - by ..]</code> becomes the first section,
and is then followed by <code>self[.. len - by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-79"><a class="doc-anchor" href="#original-79">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_right"><code>slice::rotate_right</code></a></p>
<h6 id="examples-81"><a class="doc-anchor" href="#examples-81">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//            split occurs here ^
</span>bits.rotate_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fill" class="method"><h4 class="code-header">pub fn <a href="#method.fill" class="fn">fill</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Fills the bit-slice with a given bit.</p>
<p>This is a recent stabilization in the standard library. <code>bitvec</code>
previously offered this behavior as the novel API <code>.set_all()</code>. That
method name is now removed in favor of this standard-library analogue.</p>
<h6 id="original-80"><a class="doc-anchor" href="#original-80">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill"><code>slice::fill</code></a></p>
<h6 id="examples-82"><a class="doc-anchor" href="#examples-82">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
bits.fill(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">5</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fill_with" class="method"><h4 class="code-header">pub fn <a href="#method.fill_with" class="fn">fill_with</a>&lt;F&gt;(&amp;mut self, func: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Fills the bit-slice with bits produced by a generator function.</p>
<h6 id="original-81"><a class="doc-anchor" href="#original-81">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill_with"><code>slice::fill_with</code></a></p>
<h6 id="api-differences-30"><a class="doc-anchor" href="#api-differences-30">§</a>API Differences</h6>
<p>The generator function receives the index of the bit being initialized
as an argument.</p>
<h6 id="examples-83"><a class="doc-anchor" href="#examples-83">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
bits.fill_with(|idx| idx % <span class="number">2 </span>== <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div></div></details><section id="method.clone_from_slice" class="method"><h4 class="code-header">pub fn <a href="#method.clone_from_slice" class="fn">clone_from_slice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.clone_from_bitslice()</code> instead</span></div></span><section id="method.copy_from_slice" class="method"><h4 class="code-header">pub fn <a href="#method.copy_from_slice" class="fn">copy_from_slice</a>(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.copy_from_bitslice()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.copy_within" class="method"><h4 class="code-header">pub fn <a href="#method.copy_within" class="fn">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)<div class="where">where
    R: RangeExt&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Copies a span of bits to another location in the bit-slice.</p>
<p><code>src</code> is the range of bit-indices in the bit-slice to copy, and <code>dest is the starting index of the destination range. </code>src<code>and</code>dest .. dest +
src.len()<code>are permitted to overlap; the copy will automatically detect and manage this. However, both</code>src<code>and</code>dest .. dest + src.len()<code>**must** fall within the bounds of</code>self`.</p>
<h6 id="original-82"><a class="doc-anchor" href="#original-82">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h6 id="panics-25"><a class="doc-anchor" href="#panics-25">§</a>Panics</h6>
<p>This panics if either the source or destination range exceed
<code>self.len()</code>.</p>
<h6 id="examples-84"><a class="doc-anchor" href="#examples-84">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
bits.copy_within(<span class="number">1 </span>.. <span class="number">5</span>, <span class="number">8</span>);
<span class="comment">//                        v  v  v  v
</span><span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="comment">//                                             ^  ^  ^  ^</span></code></pre></div></div></details><section id="method.swap_with_slice" class="method"><h4 class="code-header">pub fn <a href="#method.swap_with_slice" class="fn">swap_with_slice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.swap_with_bitslice()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.align_to" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fn">align_to</a>&lt;U&gt;(
    &amp;self,
) -&gt; (&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;U, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)<div class="where">where
    U: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-83"><a class="doc-anchor" href="#original-83">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h6 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-7"><a class="doc-anchor" href="#safety-7">§</a>Safety</h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-85"><a class="doc-anchor" href="#examples-85">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let </span>bits = bytes.view_bits::&lt;Lsb0&gt;();
<span class="kw">let </span>(pfx, mid, sfx) = <span class="kw">unsafe </span>{
  bits.align_to::&lt;u16&gt;()
};
<span class="macro">assert!</span>(pfx.len() &lt;= <span class="number">8</span>);
<span class="macro">assert_eq!</span>(mid.len(), <span class="number">48</span>);
<span class="macro">assert!</span>(sfx.len() &lt;= <span class="number">8</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.align_to_mut" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fn">align_to_mut</a>&lt;U&gt;(
    &amp;mut self,
) -&gt; (&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;U, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)<div class="where">where
    U: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-84"><a class="doc-anchor" href="#original-84">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a></p>
<h6 id="notes-1"><a class="doc-anchor" href="#notes-1">§</a>Notes</h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-8"><a class="doc-anchor" href="#safety-8">§</a>Safety</h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-86"><a class="doc-anchor" href="#examples-86">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let </span>bits = bytes.view_bits_mut::&lt;Lsb0&gt;();
<span class="kw">let </span>(pfx, mid, sfx) = <span class="kw">unsafe </span>{
  bits.align_to_mut::&lt;u16&gt;()
};
<span class="macro">assert!</span>(pfx.len() &lt;= <span class="number">8</span>);
<span class="macro">assert_eq!</span>(mid.len(), <span class="number">48</span>);
<span class="macro">assert!</span>(sfx.len() &lt;= <span class="number">8</span>);</code></pre></div></div></details><section id="method.to_vec" class="method"><h4 class="code-header">pub fn <a href="#method.to_vec" class="fn">to_vec</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Unalias" title="type common_base::bit_vec::prelude::BitStore::Unalias">Unalias</a>, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;">ⓘ</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.to_bitvec()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.repeat-1" class="method"><h4 class="code-header">pub fn <a href="#method.repeat-1" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Unalias" title="type common_base::bit_vec::prelude::BitStore::Unalias">Unalias</a>, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a bit-vector by repeating a bit-slice <code>n</code> times.</p>
<h6 id="original-85"><a class="doc-anchor" href="#original-85">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h6 id="panics-26"><a class="doc-anchor" href="#panics-26">§</a>Panics</h6>
<p>This method panics if <code>self.len() * n</code> exceeds the <code>BitVec</code> capacity.</p>
<h6 id="examples-87"><a class="doc-anchor" href="#examples-87">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(<span class="number">3</span>), <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>This panics by exceeding bit-vector maximum capacity:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(BitSlice::&lt;usize, Lsb0&gt;::MAX_BITS);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr-1" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitptr-1" class="fn">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-86"><a class="doc-anchor" href="#original-86">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h6 id="api-differences-31"><a class="doc-anchor" href="#api-differences-31">§</a>API Differences</h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitptr-1" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr-1" class="fn">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BitPtr.html" title="struct common_base::bit_vec::prelude::BitPtr">BitPtr</a>&lt;Mut, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw, write-capable pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-87"><a class="doc-anchor" href="#original-87">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h6 id="api-differences-32"><a class="doc-anchor" href="#api-differences-32">§</a>API Differences</h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitptr_range" class="fn">as_bitptr_range</a>(&amp;self) -&gt; <a class="struct" href="struct.BitPtrRange.html" title="struct common_base::bit_vec::prelude::BitPtrRange">BitPtrRange</a>&lt;Const, T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitPtrRange&lt;Const, T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of bit-pointers, to its first
bit <em>in</em> the bit-slice and first bit <em>beyond</em> it.</p>
<h6 id="original-88"><a class="doc-anchor" href="#original-88">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h6 id="api-differences-33"><a class="doc-anchor" href="#api-differences-33">§</a>API Differences</h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-2"><a class="doc-anchor" href="#notes-2">§</a>Notes</h6>
<p><code>BitSlice</code> does define a <a href="struct.BitSlice.html#method.as_ptr_range" title="method common_base::bit_vec::prelude::BitSlice::as_ptr_range"><code>.as_ptr_range()</code></a>, which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*const T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_bitptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr_range" class="fn">as_mut_bitptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BitPtrRange.html" title="struct common_base::bit_vec::prelude::BitPtrRange">BitPtrRange</a>&lt;Mut, T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitPtrRange&lt;Mut, T, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of write-capable bit-pointers,
to its first bit <em>in</em> the bit-slice and the first bit <em>beyond</em> it.</p>
<h6 id="original-89"><a class="doc-anchor" href="#original-89">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
<h6 id="api-differences-34"><a class="doc-anchor" href="#api-differences-34">§</a>API Differences</h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-3"><a class="doc-anchor" href="#notes-3">§</a>Notes</h6>
<p><code>BitSlice</code> does define a [<code>.as_mut_ptr_range()</code>], which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*mut T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.clone_from_bitslice" class="fn">clone_from_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h6>
<p>If <code>src</code> has the same type arguments as <code>self</code>, it will use the same
implementation as <a href="struct.BitSlice.html#method.copy_from_bitslice" title="method common_base::bit_vec::prelude::BitSlice::copy_from_bitslice"><code>.copy_from_bitslice()</code></a>; if you know that this will
always be the case, you should prefer to use that method directly.</p>
<p>Only <code>.copy_from_bitslice()</code> is <em>able</em> to perform acceleration; this
method is <em>always</em> required to perform a bit-by-bit crawl over both
bit-slices.</p>
<h6 id="original-90"><a class="doc-anchor" href="#original-90">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>slice::clone_from_slice</code></a></p>
<h6 id="api-differences-35"><a class="doc-anchor" href="#api-differences-35">§</a>API Differences</h6>
<p>This is renamed to reflect that it copies from another bit-slice, not
from an element slice.</p>
<p>In order to support general usage, it allows <code>src</code> to have different
type parameters than <code>self</code>, at the cost of performance optimizations.</p>
<h6 id="panics-27"><a class="doc-anchor" href="#panics-27">§</a>Panics</h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-88"><a class="doc-anchor" href="#examples-88">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.copy_from_bitslice" class="fn">copy_from_bitslice</a>(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)</h4></section></summary><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>, using batched acceleration when
possible.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="original-91"><a class="doc-anchor" href="#original-91">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h6 id="panics-28"><a class="doc-anchor" href="#panics-28">§</a>Panics</h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-89"><a class="doc-anchor" href="#examples-89">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_with_bitslice" class="method"><h4 class="code-header">pub fn <a href="#method.swap_with_bitslice" class="fn">swap_with_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<div class="where">where
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h4></section></summary><div class="docblock"><p>Swaps the contents of two bit-slices.</p>
<p><code>self</code> and <code>other</code> must have the same length.</p>
<h6 id="original-92"><a class="doc-anchor" href="#original-92">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h6 id="api-differences-36"><a class="doc-anchor" href="#api-differences-36">§</a>API Differences</h6>
<p>This method is renamed, as it takes a bit-slice rather than an element
slice.</p>
<h6 id="panics-29"><a class="doc-anchor" href="#panics-29">§</a>Panics</h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-90"><a class="doc-anchor" href="#examples-90">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>one = [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let </span><span class="kw-2">mut </span>two = <span class="number">0x1234u16</span>;
<span class="kw">let </span>one_bits = one.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>two_bits = two.view_bits_mut::&lt;Lsb0&gt;();

one_bits.swap_with_bitslice(two_bits);

<span class="macro">assert_eq!</span>(one, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq!</span>(two, <span class="number">0x96A5</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set" class="method"><h4 class="code-header">pub fn <a href="#method.set" class="fn">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit.</p>
<p>This is the replacement for <code>*slice[index] = value;</code>, as <code>bitvec</code> is not
able to express that under the current <code>IndexMut</code> API signature.</p>
<h6 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-30"><a class="doc-anchor" href="#panics-30">§</a>Panics</h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-91"><a class="doc-anchor" href="#examples-91">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>];
bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fn">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, without bounds checking.</p>
<h6 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters</h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-9"><a class="doc-anchor" href="#safety-9">§</a>Safety</h6>
<p>You must ensure that <code>index</code> is in the range <code>0 .. self.len()</code>.</p>
<p>This performs bit-pointer offset arithmetic without doing any bounds
checks. If <code>index</code> is out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
<h6 id="examples-92"><a class="doc-anchor" href="#examples-92">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;mut </span>data.view_bits_mut::&lt;Lsb0&gt;()[.. <span class="number">2</span>];
<span class="macro">assert_eq!</span>(bits.len(), <span class="number">2</span>);
<span class="kw">unsafe </span>{
  bits.set_unchecked(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">8</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, and returns its previous value.</p>
<h6 id="panics-31"><a class="doc-anchor" href="#panics-31">§</a>Panics</h6>
<p>This panics if <code>index</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-93"><a class="doc-anchor" href="#examples-93">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
<span class="macro">assert!</span>(!bits.replace(<span class="number">0</span>, <span class="bool-val">true</span>));
<span class="macro">assert!</span>(bits[<span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.replace_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.replace_unchecked" class="fn">replace_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, returning the previous value, without
bounds checking.</p>
<h6 id="safety-10"><a class="doc-anchor" href="#safety-10">§</a>Safety</h6>
<p><code>index</code> must be less than <code>self.len()</code>.</p>
<h6 id="examples-94"><a class="doc-anchor" href="#examples-94">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span>old = <span class="kw">unsafe </span>{
  <span class="kw">let </span>a = <span class="kw-2">&amp;mut </span>bits[.. <span class="number">1</span>];
  a.replace_unchecked(<span class="number">1</span>, <span class="bool-val">true</span>)
};
<span class="macro">assert!</span>(!old);
<span class="macro">assert!</span>(bits[<span class="number">1</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fn">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in a bit-slice, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.swap" title="method common_base::bit_vec::prelude::BitSlice::swap"><code>.swap()</code></a> for documentation.</p>
<h6 id="safety-11"><a class="doc-anchor" href="#safety-11">§</a>Safety</h6>
<p>You must ensure that <code>a</code> and <code>b</code> are both in the range <code>0 .. self.len()</code>.</p>
<p>This method performs bit-pointer offset arithmetic without doing any
bounds checks. If <code>a</code> or <code>b</code> are out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fn">split_at_unchecked</a>(
    &amp;self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; (&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;, &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a bit-slice at an index, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.split_at" title="method common_base::bit_vec::prelude::BitSlice::split_at"><code>.split_at()</code></a> for documentation.</p>
<h6 id="safety-12"><a class="doc-anchor" href="#safety-12">§</a>Safety</h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_unchecked_mut" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fn">split_at_unchecked_mut</a>(
    &amp;mut self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; (&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Alias" title="type common_base::bit_vec::prelude::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice at an index, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.split_at_mut" title="method common_base::bit_vec::prelude::BitSlice::split_at_mut"><code>.split_at_mut()</code></a> for documentation.</p>
<h6 id="safety-13"><a class="doc-anchor" href="#safety-13">§</a>Safety</h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_within_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.copy_within_unchecked" class="fn">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)<div class="where">where
    R: RangeExt&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Copies bits from one region of the bit-slice to another region of
itself, without doing bounds checks.</p>
<p>The regions are allowed to overlap.</p>
<h6 id="parameters-3"><a class="doc-anchor" href="#parameters-3">§</a>Parameters</h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: The range within <code>self</code> from which to copy.</li>
<li><code>dst</code>: The starting index within <code>self</code> at which to paste.</li>
</ul>
<h6 id="effects"><a class="doc-anchor" href="#effects">§</a>Effects</h6>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.len()]</code>. The bits of
<code>self[src]</code> are in an unspecified, but initialized, state.</p>
<h6 id="safety-14"><a class="doc-anchor" href="#safety-14">§</a>Safety</h6>
<p><code>src.end()</code> and <code>dest + src.len()</code> must be entirely within bounds.</p>
<h6 id="examples-95"><a class="doc-anchor" href="#examples-95">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0b1011_0000u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="kw">unsafe </span>{
  bits.copy_within_unchecked(.. <span class="number">4</span>, <span class="number">2</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">0b1010_1100</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bit_domain" class="method"><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fn">bit_domain</a>(&amp;self) -&gt; BitDomain&lt;'_, Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a bit-slice into maybe-contended and known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;BitSlice</code> that is as large as possible without
requiring alias protection, as well as any bits that were not able to be
included in the unaliased bit-slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_domain_mut" class="method"><h4 class="code-header">pub fn <a href="#method.bit_domain_mut" class="fn">bit_domain_mut</a>(&amp;mut self) -&gt; BitDomain&lt;'_, Mut, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a mutable bit-slice into maybe-contended and
known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;mut BitSlice</code> that is as large as possible
without requiring alias protection, as well as any bits that were not
able to be included in the unaliased bit-slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.domain" class="method"><h4 class="code-header">pub fn <a href="#method.domain" class="fn">domain</a>(&amp;self) -&gt; Domain&lt;'_, Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;[T]</code> slice with alias protections removed, covering
all elements that <code>self</code> completely fills. Partially-used elements on
either the front or back edge of the slice are returned separately.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.domain_mut" class="method"><h4 class="code-header">pub fn <a href="#method.domain_mut" class="fn">domain_mut</a>(&amp;mut self) -&gt; Domain&lt;'_, Mut, T, O&gt;</h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;mut [T]</code> slice with alias protections removed,
covering all elements that <code>self</code> completely fills. Partially-used
elements on the front or back edge of the slice are returned separately.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones" class="method"><h4 class="code-header">pub fn <a href="#method.count_ones" class="fn">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the bit-slice contents.</p>
<h6 id="examples-96"><a class="doc-anchor" href="#examples-96">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_ones(), <span class="number">0</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.count_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fn">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the bit-slice contents.</p>
<h6 id="examples-97"><a class="doc-anchor" href="#examples-97">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_zeros(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_zeros(), <span class="number">0</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iter_ones" class="method"><h4 class="code-header">pub fn <a href="#method.iter_ones" class="fn">iter_ones</a>(&amp;self) -&gt; IterOnes&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice set to <code>1</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>true</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-98"><a class="doc-anchor" href="#examples-98">§</a>Examples</h6>
<p>This example uses <code>.iter_ones()</code>, a <code>.filter_map()</code> that finds the index
of each set bit, and the known indices, in order to show that they have
equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let </span>iter_ones = bits.iter_ones();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_ones.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_one, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_one, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iter_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.iter_zeros" class="fn">iter_zeros</a>(&amp;self) -&gt; IterZeros&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice cleared to <code>0</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>false</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-99"><a class="doc-anchor" href="#examples-99">§</a>Examples</h6>
<p>This example uses <code>.iter_zeros()</code>, a <code>.filter_map()</code> that finds the
index of each cleared bit, and the known indices, in order to show that
they have equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">let </span>iter_zeros = bits.iter_zeros();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>!bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_zeros.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_zero, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_zero, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first_one" class="method"><h4 class="code-header">pub fn <a href="#method.first_one" class="fn">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-100"><a class="doc-anchor" href="#examples-100">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].first_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].first_one(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first_zero" class="method"><h4 class="code-header">pub fn <a href="#method.first_zero" class="fn">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-101"><a class="doc-anchor" href="#examples-101">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].first_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].first_zero(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last_one" class="method"><h4 class="code-header">pub fn <a href="#method.last_one" class="fn">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-102"><a class="doc-anchor" href="#examples-102">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].last_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].last_one(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last_zero" class="method"><h4 class="code-header">pub fn <a href="#method.last_zero" class="fn">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-103"><a class="doc-anchor" href="#examples-103">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].last_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].last_zero(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leading_ones" class="method"><h4 class="code-header">pub fn <a href="#method.leading_ones" class="fn">leading_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-104"><a class="doc-anchor" href="#examples-104">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].leading_ones(), <span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leading_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.leading_zeros" class="fn">leading_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-105"><a class="doc-anchor" href="#examples-105">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].leading_zeros(), <span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_ones" class="method"><h4 class="code-header">pub fn <a href="#method.trailing_ones" class="fn">trailing_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-106"><a class="doc-anchor" href="#examples-106">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].trailing_ones(), <span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.trailing_zeros" class="fn">trailing_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-107"><a class="doc-anchor" href="#examples-107">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].trailing_zeros(), <span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.any" class="method"><h4 class="code-header">pub fn <a href="#method.any" class="fn">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if there is at least one bit set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-108"><a class="doc-anchor" href="#examples-108">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].any());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].any());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.all" class="method"><h4 class="code-header">pub fn <a href="#method.all" class="fn">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-109"><a class="doc-anchor" href="#examples-109">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">1</span>].all());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.not_any" class="method"><h4 class="code-header">pub fn <a href="#method.not_any" class="fn">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-110"><a class="doc-anchor" href="#examples-110">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].not_any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_any());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_any());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.not_all" class="method"><h4 class="code-header">pub fn <a href="#method.not_all" class="fn">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-111"><a class="doc-anchor" href="#examples-111">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].not_all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_all());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.some" class="method"><h4 class="code-header">pub fn <a href="#method.some" class="fn">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is set to <code>1</code>, and at least one bit is cleared
to <code>0</code>, in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-112"><a class="doc-anchor" href="#examples-112">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].some());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].some());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.shift_left" class="method"><h4 class="code-header">pub fn <a href="#method.shift_left" class="fn">shift_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “left” (towards the zero-index),
clearing the “right” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking <code>bits = &amp;bits[by ..]</code>: it
has to modify the entire memory region that <code>bits</code> governs, and destroys
contained information. Unless the actual memory layout and contents of
your bit-slice matters to your program, you should <em>probably</em> prefer to
munch your way forward through a bit-slice handle.</p>
<p>Note also that the “left” here is semantic only, and <strong>does not</strong>
necessarily correspond to a left-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-32"><a class="doc-anchor" href="#panics-32">§</a>Panics</h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-113"><a class="doc-anchor" href="#examples-113">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits are retained ^--------------------------^
</span>bits.shift_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">// and move here       ^--------------------------^

</span><span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">2</span>];
bits.shift_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.shift_right" class="method"><h4 class="code-header">pub fn <a href="#method.shift_right" class="fn">shift_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “right” (away from the zero-index),
clearing the “left” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking `bits = &amp;bits[.. bits.len()</p>
<ul>
<li>by]<code>: it must modify the entire memory region that </code>bits` governs, and
destroys contained information. Unless the actual memory layout and
contents of your bit-slice matters to your program, you should
<em>probably</em> prefer to munch your way backward through a bit-slice handle.</li>
</ul>
<p>Note also that the “right” here is semantic only, and <strong>does not</strong>
necessarily correspond to a right-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-33"><a class="doc-anchor" href="#panics-33">§</a>Panics</h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-114"><a class="doc-anchor" href="#examples-114">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits stay   ^--------------------------^
</span>bits.shift_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="comment">// and move here             ^--------------------------^

</span><span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">2</span>];
bits.shift_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_aliased" class="method"><h4 class="code-header">pub fn <a href="#method.set_aliased" class="fn">set_aliased</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations.</p>
<p>This is equivalent to <a href="struct.BitSlice.html#method.set" title="method common_base::bit_vec::prelude::BitSlice::set"><code>.set()</code></a>, except that it does not require an
<code>&amp;mut</code> reference, and allows bit-slices with alias-safe storage to share
write permissions.</p>
<h6 id="parameters-4"><a class="doc-anchor" href="#parameters-4">§</a>Parameters</h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-34"><a class="doc-anchor" href="#panics-34">§</a>Panics</h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-115"><a class="doc-anchor" href="#examples-115">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>BitSlice&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = <span class="macro">bits!</span>[Cell&lt;usize&gt;, Lsb0; <span class="number">0</span>, <span class="number">1</span>];
bits.set_aliased(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set_aliased(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_aliased_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.set_aliased_unchecked" class="fn">set_aliased_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations and
without bounds checking.</p>
<p>This is equivalent to <a href="struct.BitSlice.html#method.set_unchecked" title="method common_base::bit_vec::prelude::BitSlice::set_unchecked"><code>.set_unchecked()</code></a>, except that it does not
require an <code>&amp;mut</code> reference, and allows bit-slices with alias-safe
storage to share write permissions.</p>
<h6 id="parameters-5"><a class="doc-anchor" href="#parameters-5">§</a>Parameters</h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-15"><a class="doc-anchor" href="#safety-15">§</a>Safety</h6>
<p>The caller must ensure that <code>index</code> is not out of bounds.</p>
<h6 id="examples-116"><a class="doc-anchor" href="#examples-116">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>data = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">2</span>];
<span class="kw">unsafe </span>{
  bits.set_aliased_unchecked(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data.get(), <span class="number">8</span>);</code></pre></div></div></details><section id="associatedconstant.MAX_BITS" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section><section id="associatedconstant.MAX_ELTS" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = BitSpan&lt;Const, T, O&gt;::REGION_MAX_ELTS</h4></section><details class="toggle method-toggle" open><summary><section id="method.to_bitvec" class="method"><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fn">to_bitvec</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;&lt;T as <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="trait.BitStore.html#associatedtype.Unalias" title="type common_base::bit_vec::prelude::BitStore::Unalias">Unalias</a>, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Copies a bit-slice into an owned bit-vector.</p>
<p>Since the new vector is freshly owned, this gets marked as <code>::Unalias</code>
to remove any guards that may have been inserted by the bit-slice’s
history.</p>
<p>It does <em>not</em> use the underlying memory type, so that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> will produce a <code>BitVec&lt;_, Cell&lt;_&gt;&gt;</code>.</p>
<h6 id="original-93"><a class="doc-anchor" href="#original-93">§</a>Original</h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></p>
<h6 id="examples-117"><a class="doc-anchor" href="#examples-117">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = bits.to_bitvec();
<span class="macro">assert_eq!</span>(bits, bv);</code></pre></div></div></details></div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-AsMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl"><a href="#method.as_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-AsMut%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut-1" class="method trait-impl"><a href="#method.as_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-AsRef%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a href="#method.as_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-AsRef%3CBitVec%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl"><a href="#method.as_ref-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Binary-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Binary-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAnd%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>&amp;</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitand" class="method trait-impl"><a href="#method.bitand" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fn">bitand</a>(self, rhs: Rhs) -&gt; &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&lt;BitVec&lt;T, O&gt; as BitAnd&lt;Rhs&gt;&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the <code>&amp;</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#tymethod.bitand">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitAndAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitand_assign-1" class="method trait-impl"><a href="#method.bitand_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fn">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitAndAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl"><a href="#method.bitand_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fn">bitand_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitand_assign-2" class="method trait-impl"><a href="#method.bitand_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fn">bitand_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitField-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitField-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitField</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitField</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl"><a href="#method.load_le" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#tymethod.load_le" class="fn">load_le</a>&lt;I&gt;(&amp;self) -&gt; I<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Little-Endian Integer Loading <a href="trait._.html#tymethod.load_le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl"><a href="#method.load_be" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#tymethod.load_be" class="fn">load_be</a>&lt;I&gt;(&amp;self) -&gt; I<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Big-Endian Integer Loading <a href="trait._.html#tymethod.load_be">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl"><a href="#method.store_le" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#tymethod.store_le" class="fn">store_le</a>&lt;I&gt;(&amp;mut self, value: I)<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Little-Endian Integer Storing <a href="trait._.html#tymethod.store_le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl"><a href="#method.store_be" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#tymethod.store_be" class="fn">store_be</a>&lt;I&gt;(&amp;mut self, value: I)<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Big-Endian Integer Storing <a href="trait._.html#tymethod.store_be">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.load" class="method trait-impl"><a href="#method.load" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#method.load" class="fn">load</a>&lt;I&gt;(&amp;self) -&gt; I<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Integer Loading <a href="trait._.html#method.load">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.store" class="method trait-impl"><a href="#method.store" class="anchor">§</a><h4 class="code-header">fn <a href="trait._.html#method.store" class="fn">store</a>&lt;I&gt;(&amp;mut self, value: I)<div class="where">where
    I: Integral,</div></h4></section></summary><div class='docblock'>Integer Storing <a href="trait._.html#method.store">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOr%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>|</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitor" class="method trait-impl"><a href="#method.bitor" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fn">bitor</a>(self, rhs: Rhs) -&gt; &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&lt;BitVec&lt;T, O&gt; as BitOr&lt;Rhs&gt;&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the <code>|</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#tymethod.bitor">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitOrAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitor_assign-1" class="method trait-impl"><a href="#method.bitor_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fn">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitOrAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl"><a href="#method.bitor_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fn">bitor_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitor_assign-2" class="method trait-impl"><a href="#method.bitor_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fn">bitor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXor%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>^</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.bitxor" class="method trait-impl"><a href="#method.bitxor" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fn">bitxor</a>(self, rhs: Rhs) -&gt; &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&lt;BitVec&lt;T, O&gt; as BitXor&lt;Rhs&gt;&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the <code>^</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#tymethod.bitxor">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitXorAssign%3C%26BitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitxor_assign-1" class="method trait-impl"><a href="#method.bitxor_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fn">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="impl"><a href="#impl-BitXorAssign%3CBitVec%3CT,+O%3E%3E-for-BitSlice%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl"><a href="#method.bitxor_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fn">bitxor_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bitxor_assign-2" class="method trait-impl"><a href="#method.bitxor_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fn">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Borrow%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-BorrowMut%3CBitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="&amp;mut BitSlice&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Clone-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Debug-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Default-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-DerefMut-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fn">deref_mut</a>(&amp;mut self) -&gt; &amp;mut &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a> <a href="#" class="tooltip" data-notable-ty="&amp;mut &lt;BitVec&lt;T, O&gt; as Deref&gt;::Target">ⓘ</a></h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Display-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl"><a href="#method.fmt-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Drop-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26T%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Extend%3C%26T%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-4" class="method trait-impl"><a href="#method.extend-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#417">Source</a><a href="#method.extend_one-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#425">Source</a><a href="#method.extend_reserve-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26bool%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Extend%3C%26bool%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl"><a href="#method.extend-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#417">Source</a><a href="#method.extend_one-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#425">Source</a><a href="#method.extend_reserve-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" class="impl"><a href="#impl-Extend%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, M, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'a, M, T2, O2&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T1, O1&gt;<div class="where">where
    M: Mutability,
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><h4 id="bit-vector-extension-by-proxy-references"><a class="doc-anchor" href="#bit-vector-extension-by-proxy-references">§</a>Bit-Vector Extension by Proxy References</h4>
<p><strong>DO NOT</strong> use this. You <em>clearly</em> have a bit-slice. Use
<a href="struct.BitVec.html#method.extend_from_bitslice" title="method common_base::bit_vec::prelude::BitVec::extend_from_bitslice"><code>.extend_from_bitslice()</code></a> instead!</p>
</div></section></summary><div class="docblock"><p>Iterating over a bit-slice requires loading from memory and constructing a proxy
reference for each bit. This is needlessly slow; the specialized method is able
to avoid this per-bit cost and possibly even use batched operations.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-2" class="method trait-impl"><a href="#method.extend-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'a, M, T2, O2&gt;&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#417">Source</a><a href="#method.extend_one-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#425">Source</a><a href="#method.extend_reserve-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3CT%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Extend%3CT%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-3" class="method trait-impl"><a href="#method.extend-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#417">Source</a><a href="#method.extend_one-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#425">Source</a><a href="#method.extend_reserve-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3Cbool%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><h4 id="bit-vector-extension"><a class="doc-anchor" href="#bit-vector-extension">§</a>Bit-Vector Extension</h4>
<p>This extends a bit-vector from anything that produces individual bits.</p>
</div></section></summary><div class="docblock"><h5 id="original-97"><a class="doc-anchor" href="#original-97">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-Extend%3CT%3E"><code>impl&lt;T&gt; Extend&lt;T&gt; for Vec&lt;T&gt;</code></a></p>
<h5 id="notes-5"><a class="doc-anchor" href="#notes-5">§</a>Notes</h5>
<p>This <code>.extend()</code> call is the second-slowest possible way to append bits into a
bit-vector, faster only than calling <code>iter.for_each(|bit| bv.push(bit))</code>.
<strong>DO NOT</strong> use this if you have any other choice.</p>
<p>If you are extending a bit-vector from the contents of a bit-slice, then you
should use <a href="struct.BitVec.html#method.extend_from_bitslice" title="method common_base::bit_vec::prelude::BitVec::extend_from_bitslice"><code>.extend_from_bitslice()</code></a> instead. That method is specialized to
perform upfront allocation and, where possible, use a batch copy rather than
copying each bit individually from the source into the bit-vector.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl"><a href="#method.extend" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#417">Source</a><a href="#method.extend_one" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#425">Source</a><a href="#method.extend_reserve" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-From%3C%26BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(slice: &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26mut+BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-From%3C%26mut+BitSlice%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(slice: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitArray%3CA,+O%3E%3E-for-BitVec%3C%3CA+as+BitView%3E::Store,+O%3E" class="impl"><a href="#impl-From%3CBitArray%3CA,+O%3E%3E-for-BitVec%3C%3CA+as+BitView%3E::Store,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitArray.html" title="struct common_base::bit_vec::prelude::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;&lt;A as <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitView</a>&gt;::<a class="associatedtype" href="trait._.html#associatedtype.Store" title="type common_base::bit_vec::prelude::_::Store">Store</a>, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    A: <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitViewSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(array: <a class="struct" href="struct.BitArray.html" title="struct common_base::bit_vec::prelude::BitArray">BitArray</a>&lt;A, O&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;&lt;A as <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitView</a>&gt;::<a class="associatedtype" href="trait._.html#associatedtype.Store" title="type common_base::bit_vec::prelude::_::Store">Store</a>, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;&lt;A as BitView&gt;::Store, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-From%3CBitBox%3CT,+O%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(boxed: <a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CT,+O%3E%3E-for-BitBox%3CT,+O%3E" class="impl"><a href="#impl-From%3CBitVec%3CT,+O%3E%3E-for-BitBox%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(bv: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;) -&gt; <a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CT,+O%3E%3E-for-Vec%3CT%3E" class="impl"><a href="#impl-From%3CBitVec%3CT,+O%3E%3E-for-Vec%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(bv: <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CCow%3C'a,+BitSlice%3CT,+O%3E%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-From%3CCow%3C'a,+BitSlice%3CT,+O%3E%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: 'a + <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(cow: <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26T%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-FromIterator%3C%26T%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-4" class="method trait-impl"><a href="#method.from_iter-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26bool%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-FromIterator%3C%26bool%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-1" class="method trait-impl"><a href="#method.from_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" class="impl"><a href="#impl-FromIterator%3CBitRef%3C'a,+M,+T2,+O2%3E%3E-for-BitVec%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, M, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'a, M, T2, O2&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T1, O1&gt;<div class="where">where
    M: Mutability,
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><h4 id="bit-vector-collection-from-proxy-references"><a class="doc-anchor" href="#bit-vector-collection-from-proxy-references">§</a>Bit-Vector Collection from Proxy References</h4>
<p><strong>DO NOT</strong> use this. You <em>clearly</em> have a bit-slice. Use
<a href="struct.BitVec.html#method.from_bitslice" title="associated function common_base::bit_vec::prelude::BitVec::from_bitslice"><code>::from_bitslice()</code></a> instead!</p>
</div></section></summary><div class="docblock"><p>Iterating over a bit-slice requires loading from memory and constructing a proxy
reference for each bit. This is needlessly slow; the specialized method is able
to avoid this per-bit cost and possibly even use batched operations.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-2" class="method trait-impl"><a href="#method.from_iter-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T1, O1&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T1, O1&gt;">ⓘ</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="struct.BitRef.html" title="struct common_base::bit_vec::prelude::BitRef">BitRef</a>&lt;'a, M, T2, O2&gt;&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CT%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-FromIterator%3CT%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-3" class="method trait-impl"><a href="#method.from_iter-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3Cbool%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><h4 id="bit-vector-collection"><a class="doc-anchor" href="#bit-vector-collection">§</a>Bit-Vector Collection</h4>
<p>This collects a bit-vector from anything that produces individual bits.</p>
</div></section></summary><div class="docblock"><h5 id="original-95"><a class="doc-anchor" href="#original-95">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-FromIterator%3CT%3E"><code>impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt;</code></a></p>
<h5 id="notes-4"><a class="doc-anchor" href="#notes-4">§</a>Notes</h5>
<p>This <code>.collect()</code> call is the second-slowest possible way to collect bits into a
bit-vector, faster only than calling <code>iter.for_each(|bit| bv.push(bit))</code>.
<strong>DO NOT</strong> use this if you have any other choice.</p>
<p>If you are collecting a bit-vector from the contents of a bit-slice, then you
should use <a href="struct.BitVec.html#method.extend_from_bitslice" title="method common_base::bit_vec::prelude::BitVec::extend_from_bitslice"><code>::from_bitslice()</code></a> instead. That method is specialized to
perform upfront allocation and, where possible, use a batch copy rather than
copying each bit individually from the source into the bit-vector.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a href="#method.from_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; <a href="#" class="tooltip" data-notable-ty="BitVec&lt;T, O&gt;">ⓘ</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Hash-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3CIdx%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Index%3CIdx%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index" class="method trait-impl"><a href="#method.index" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fn">index</a>(&amp;self, index: Idx) -&gt; &amp;&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;&lt;BitVec&lt;T, O&gt; as Index&lt;Idx&gt;&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CIdx%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl"><a href="#method.index_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fn">index_mut</a>(&amp;mut self, index: Idx) -&gt; &amp;mut &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;mut &lt;BitVec&lt;T, O&gt; as Index&lt;Idx&gt;&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26BitVec%3CT,+O%3E" class="impl"><a href="#impl-IntoIterator-for-%26BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: 'a + <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3><div class="docblock"><p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-IntoIterator-1">Original</a></p>
</div></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a href="#method.into_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; &lt;&amp;'a <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> <a href="#" class="tooltip" data-notable-ty="&lt;&amp;&#39;a BitVec&lt;T, O&gt; as IntoIterator&gt;::IntoIter">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26mut+BitVec%3CT,+O%3E" class="impl"><a href="#impl-IntoIterator-for-%26mut+BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: 'a + <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3><div class="docblock"><p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-IntoIterator-2">Original</a></p>
</div></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-2" class="associatedtype trait-impl"><a href="#associatedtype.Item-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-2" class="method trait-impl"><a href="#method.into_iter-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; &lt;&amp;'a mut <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> <a href="#" class="tooltip" data-notable-ty="&lt;&amp;&#39;a mut BitVec&lt;T, O&gt; as IntoIterator&gt;::IntoIter">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-IntoIterator-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><h4 id="bit-vector-iteration"><a class="doc-anchor" href="#bit-vector-iteration">§</a>Bit-Vector Iteration</h4>
<p>Bit-vectors have the advantage that iteration consumes the whole structure, so
they can simply freeze the allocation into a bit-box, then use its iteration and
destructor.</p>
</div></section></summary><div class="docblock"><h5 id="original-94"><a class="doc-anchor" href="#original-94">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#impl-IntoIterator"><code>impl&lt;T&gt; IntoIterator for Vec&lt;T&gt;</code></a></p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;<a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="struct.BitBox.html" title="struct common_base::bit_vec::prelude::BitBox">BitBox</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> <a href="#" class="tooltip" data-notable-ty="&lt;BitVec&lt;T, O&gt; as IntoIterator&gt;::IntoIter">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LowerHex-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-LowerHex-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl"><a href="#method.fmt-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Not-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Not-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3><div class="docblock"><p>This implementation inverts all elements in the live buffer. You cannot rely
on the value of bits in the buffer that are outside the domain of
<a href="struct.BitVec.html#method.as_mut_bitslice" title="method common_base::bit_vec::prelude::BitVec::as_mut_bitslice"><code>BitVec::as_mut_bitslice</code></a>.</p>
</div></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>!</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.not" class="method trait-impl"><a href="#method.not" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not" class="fn">not</a>(self) -&gt; &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&lt;BitVec&lt;T, O&gt; as Not&gt;::Output">ⓘ</a></h4></section></summary><div class='docblock'>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Octal-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Octal-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl"><a href="#method.fmt-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Ord-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1021-1023">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1060-1062">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1086-1088">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialEq%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    Rhs: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a href="#method.eq-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a href="#method.partial_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1398">Source</a></span><a href="#method.lt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1416">Source</a></span><a href="#method.le-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1434">Source</a></span><a href="#method.gt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1452">Source</a></span><a href="#method.ge-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-%26mut+BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl"><a href="#method.partial_cmp-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1398">Source</a></span><a href="#method.lt-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1416">Source</a></span><a href="#method.le-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1434">Source</a></span><a href="#method.gt-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1452">Source</a></span><a href="#method.ge-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" class="impl"><a href="#impl-PartialOrd%3CBitVec%3CT2,+O2%3E%3E-for-BitSlice%3CT1,+O1%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T1, O1&gt;<div class="where">where
    T1: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    T2: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O1: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    O2: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1398">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1416">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1434">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1452">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CRhs%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    Rhs: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-3" class="method trait-impl"><a href="#method.partial_cmp-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1398">Source</a></span><a href="#method.lt-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1416">Source</a></span><a href="#method.le-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1434">Source</a></span><a href="#method.gt-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1452">Source</a></span><a href="#method.ge-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Pointer-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-6" class="method trait-impl"><a href="#method.fmt-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Read-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Read-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitField</a>,</div></h3><div class="docblock"><h4 id="reading-from-a-bit-vector"><a class="doc-anchor" href="#reading-from-a-bit-vector">§</a>Reading From a Bit-Vector</h4>
<p>The implementation loads bytes out of the reference bit-vector until either the
destination buffer is filled or the source has no more bytes to provide. When
<code>.read()</code> returns, the provided bit-vector will have its contents shifted down
so that it begins at the first bit <em>after</em> the last byte copied out into <code>buf</code>.</p>
</div></section></summary><div class="docblock"><p>Note that the return value of <code>.read()</code> is always the number of <em>bytes</em> of <code>buf</code>
filled!</p>
<h5 id="api-differences-37"><a class="doc-anchor" href="#api-differences-37">§</a>API Differences</h5>
<p>The standard library does not <code>impl Read for Vec&lt;u8&gt;</code>. It is provided here as a
courtesy.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read" class="method trait-impl"><a href="#method.read" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#tymethod.read" class="fn">read</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Pull some bytes from this source into the specified buffer, returning
how many bytes were read. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#tymethod.read">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_vectored" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#825">Source</a></span><a href="#method.read_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_vectored" class="fn">read_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.IoSliceMut.html" title="struct std::io::IoSliceMut">IoSliceMut</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <code>read</code>, except that it reads into a slice of buffers. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_read_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#838">Source</a><a href="#method.is_read_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.is_read_vectored" class="fn">is_read_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code>
implementation. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.is_read_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_end" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#935">Source</a></span><a href="#method.read_to_end" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_end" class="fn">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Reads all bytes until EOF in this source, placing them into <code>buf</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_end">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_string" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#991">Source</a></span><a href="#method.read_to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_string" class="fn">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Reads all bytes until EOF in this source, appending them to <code>buf</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_string">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_exact" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1044">Source</a></span><a href="#method.read_exact" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_exact" class="fn">read_exact</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Reads the exact number of bytes required to fill <code>buf</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_exact">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_buf" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1057">Source</a><a href="#method.read_buf" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_buf" class="fn">read_buf</a>(&amp;mut self, buf: <a class="struct" href="https://doc.rust-lang.org/nightly/core/io/borrowed_buf/struct.BorrowedCursor.html" title="struct core::io::borrowed_buf::BorrowedCursor">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Pull some bytes from this source into the specified buffer. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_buf">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.read_buf_exact" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1080">Source</a><a href="#method.read_buf_exact" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_buf_exact" class="fn">read_buf_exact</a>(&amp;mut self, cursor: <a class="struct" href="https://doc.rust-lang.org/nightly/core/io/borrowed_buf/struct.BorrowedCursor.html" title="struct core::io::borrowed_buf::BorrowedCursor">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Reads the exact number of bytes required to fill <code>cursor</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_buf_exact">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1119-1121">Source</a></span><a href="#method.by_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Read</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.by_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1162-1164">Source</a></span><a href="#method.bytes" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.bytes" class="fn">bytes</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.Bytes.html" title="struct std::io::Bytes">Bytes</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Transforms this <code>Read</code> instance to an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> over its bytes. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1200-1202">Source</a></span><a href="#method.chain" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chain" class="fn">chain</a>&lt;R&gt;(self, next: R) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.Chain.html" title="struct std::io::Chain">Chain</a>&lt;Self, R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an adapter which will chain this stream with another. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chain">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.take" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1239-1241">Source</a></span><a href="#method.take" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.take" class="fn">take</a>(self, limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.Take.html" title="struct std::io::Take">Take</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an adapter which will read at most <code>limit</code> bytes from it. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.take">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-TryFrom%3CVec%3CT%3E%3E-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(
    vec: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;, &lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-UpperHex-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-UpperHex-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl"><a href="#method.fmt-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Write-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Write-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="trait._.html" title="trait common_base::bit_vec::prelude::_">BitField</a>,</div></h3><div class="docblock"><h4 id="writing-into-a-bit-vector-1"><a class="doc-anchor" href="#writing-into-a-bit-vector-1">§</a>Writing Into a Bit-Vector</h4>
<p>The implementation appends bytes to the referenced bit-vector until the source
buffer is exhausted.</p>
</div></section></summary><div class="docblock"><p>Note that the return value of <code>.write()</code> is always the number of <em>bytes</em> of
<code>buf</code> consumed!</p>
<p>The implementation uses <a href="trait._.html#tymethod.store_be" title="method common_base::bit_vec::prelude::_::store_be"><code>BitField::store_be</code></a> to fill bytes. Note that unlike
the standard library, it is implemented on bit-vectors of <em>any</em> underlying
element type. However, using a <code>BitVec&lt;_, u8&gt;</code> is still likely to be fastest.</p>
<h5 id="original-96"><a class="doc-anchor" href="#original-96">§</a>Original</h5>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Write"><code>impl Write for Vec&lt;u8&gt;</code></a></p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write" class="method trait-impl"><a href="#method.write" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write" class="fn">write</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Writes a buffer into this writer, returning how many bytes were written. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method trait-impl"><a href="#method.flush" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush" class="fn">flush</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Flushes this output stream, ensuring that all intermediately buffered
contents reach their destination. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_vectored" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1758">Source</a></span><a href="#method.write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_vectored" class="fn">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write" title="method std::io::Write::write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_write_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1773">Source</a><a href="#method.is_write_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.is_write_vectored" class="fn">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_vectored" title="method std::io::Write::write_vectored"><code>write_vectored</code></a>
implementation. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.is_write_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_all" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1835">Source</a></span><a href="#method.write_all" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all" class="fn">write_all</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Attempts to write an entire buffer into this writer. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_all_vectored" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1897">Source</a><a href="#method.write_all_vectored" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all_vectored" class="fn">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all_vectored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.write_fmt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1950">Source</a></span><a href="#method.write_fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt" class="fn">write_fmt</a>(&amp;mut self, args: <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html" title="struct core::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error
encountered. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1980-1982">Source</a></span><a href="#method.by_ref-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-__Deref-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-__Deref-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="struct.BitSlice.html" title="struct common_base::bit_vec::prelude::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;&lt;<a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a> <a href="#" class="tooltip" data-notable-ty="&amp;&lt;BitVec&lt;T, O&gt; as Deref&gt;::Target">ⓘ</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><section id="impl-Eq-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Eq-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section><section id="impl-Send-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Send-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section><section id="impl-Sync-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Sync-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section><section id="impl-Unpin-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Unpin-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    T: <a class="trait" href="trait.BitStore.html" title="trait common_base::bit_vec::prelude::BitStore">BitStore</a>,
    O: <a class="trait" href="trait.BitOrder.html" title="trait common_base::bit_vec::prelude::BitOrder">BitOrder</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Freeze-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;</h3></section><section id="impl-RefUnwindSafe-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-RefUnwindSafe-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-UnwindSafe-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-UnwindSafe-for-BitVec%3CT,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct common_base::bit_vec::prelude::BitVec">BitVec</a>&lt;T, O&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Comparable%3CK%3E-for-Q" class="impl"><a href="#impl-Comparable%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Comparable&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compare" class="method trait-impl"><a href="#method.compare" class="anchor">§</a><h4 class="code-header">fn <a class="fn">compare</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return their ordering.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Conv-for-T" class="impl"><a href="#impl-Conv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Conv for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl"><a href="#method.conv" class="anchor">§</a><h4 class="code-header">fn <a class="fn">conv</a>&lt;T&gt;(self) -&gt; T<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FmtForward-for-T" class="impl"><a href="#impl-FmtForward-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; FmtForward for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl"><a href="#method.fmt_binary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_binary</a>(self) -&gt; FmtBinary&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl"><a href="#method.fmt_display" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_display</a>(self) -&gt; FmtDisplay&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl"><a href="#method.fmt_lower_exp" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_lower_exp</a>(self) -&gt; FmtLowerExp&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl"><a href="#method.fmt_lower_hex" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_lower_hex</a>(self) -&gt; FmtLowerHex&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl"><a href="#method.fmt_octal" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_octal</a>(self) -&gt; FmtOctal&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl"><a href="#method.fmt_pointer" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_pointer</a>(self) -&gt; FmtPointer&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl"><a href="#method.fmt_upper_exp" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_upper_exp</a>(self) -&gt; FmtUpperExp&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl"><a href="#method.fmt_upper_hex" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_upper_hex</a>(self) -&gt; FmtUpperHex&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_list" class="method trait-impl"><a href="#method.fmt_list" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_list</a>(self) -&gt; FmtList&lt;Self&gt;<div class="where">where
    &amp;'a Self: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,</div></h4></section></summary><div class='docblock'>Formats each item in a sequence. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pipe-for-T" class="impl"><a href="#impl-Pipe-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pipe for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl"><a href="#method.pipe" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Pipes by value. This is generally the method you want to use. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl"><a href="#method.pipe_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code> and passes that borrow into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl"><a href="#method.pipe_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl"><a href="#method.pipe_borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a B</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl"><a href="#method.pipe_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_borrow_mut</a>&lt;'a, B, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut B</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl"><a href="#method.pipe_as_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a U</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,
    U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl"><a href="#method.pipe_as_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut U</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,
    U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl"><a href="#method.pipe_deref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a>) -&gt; R) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl"><a href="#method.pipe_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_deref_mut</a>&lt;'a, T, R&gt;(
    &amp;'a mut self,
    func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a>) -&gt; R,
) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Receiver-for-P" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#378-380">Source</a><a href="#impl-Receiver-for-P" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Receiver.html" title="trait core::ops::deref::Receiver">Receiver</a> for P<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#382">Source</a><a href="#associatedtype.Target-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Receiver.html#associatedtype.Target" class="associatedtype">Target</a> = T</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code>)</span></div></span><div class='docblock'>The target type on which the method may be called.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Tap-for-T" class="impl"><a href="#impl-Tap-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Tap for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl"><a href="#method.tap" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self)) -&gt; Self</h4></section></summary><div class='docblock'>Immutable access to a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl"><a href="#method.tap_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self)) -&gt; Self</h4></section></summary><div class='docblock'>Mutable access to a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl"><a href="#method.tap_borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl"><a href="#method.tap_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl"><a href="#method.tap_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl"><a href="#method.tap_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl"><a href="#method.tap_deref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Deref::Target</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl"><a href="#method.tap_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>Deref::Target</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl"><a href="#method.tap_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl"><a href="#method.tap_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl"><a href="#method.tap_borrow_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl"><a href="#method.tap_borrow_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut B</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,
    B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl"><a href="#method.tap_ref_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl"><a href="#method.tap_ref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut R</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,
    R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl"><a href="#method.tap_deref_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl"><a href="#method.tap_deref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2783">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2785">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryConv-for-T" class="impl"><a href="#impl-TryConv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; TryConv for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl"><a href="#method.try_conv" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Any-for-T-1" class="impl"><a href="#impl-Any-for-T-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a>,</div></h3></section><section id="impl-CloneAny-for-T" class="impl"><a href="#impl-CloneAny-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneAny for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section><section id="impl-CloneAnySend-for-T" class="impl"><a href="#impl-CloneAnySend-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneAnySend for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section><section id="impl-CloneAnySendSync-for-T" class="impl"><a href="#impl-CloneAnySendSync-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneAnySendSync for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section><section id="impl-CloneAnySync-for-T" class="impl"><a href="#impl-CloneAnySync-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneAnySync for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"&'a mut BitSlice<T, O>":"<h3>Notable traits for <code>&amp;mut <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&<BitVec<T, O> as Deref>::Target":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&<BitVec<T, O> as Index<Idx>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&BitSlice<T, O>":"<h3>Notable traits for <code>&amp;<a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;<a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&BitVec<T, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&mut <BitVec<T, O> as Deref>::Target":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&mut <BitVec<T, O> as Index<Idx>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&mut BitSlice<T, O>":"<h3>Notable traits for <code>&amp;mut <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","&mut BitVec<T, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<&'a BitVec<T, O> as IntoIterator>::IntoIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<&'a mut BitVec<T, O> as IntoIterator>::IntoIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<BitVec<T, O> as BitAnd<Rhs>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<BitVec<T, O> as BitOr<Rhs>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<BitVec<T, O> as BitXor<Rhs>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<BitVec<T, O> as IntoIterator>::IntoIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","<BitVec<T, O> as Not>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","BitPtrRange<Const, T, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitPtrRange.html\" title=\"struct common_base::bit_vec::prelude::BitPtrRange\">BitPtrRange</a>&lt;M, T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;M, T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.BitPtrRange.html\" title=\"struct common_base::bit_vec::prelude::BitPtrRange\">BitPtrRange</a>&lt;M, T, O&gt;<div class=\"where\">where\n    M: Mutability,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.BitPtr.html\" title=\"struct common_base::bit_vec::prelude::BitPtr\">BitPtr</a>&lt;M, T, O&gt;;</div>","BitPtrRange<Mut, T, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitPtrRange.html\" title=\"struct common_base::bit_vec::prelude::BitPtrRange\">BitPtrRange</a>&lt;M, T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;M, T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.BitPtrRange.html\" title=\"struct common_base::bit_vec::prelude::BitPtrRange\">BitPtrRange</a>&lt;M, T, O&gt;<div class=\"where\">where\n    M: Mutability,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.BitPtr.html\" title=\"struct common_base::bit_vec::prelude::BitPtr\">BitPtr</a>&lt;M, T, O&gt;;</div>","BitVec<<A as BitView>::Store, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","BitVec<<T as BitStore>::Unalias, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","BitVec<T, O>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>","BitVec<T1, O1>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div><div class=\"where\">impl&lt;T, O&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"struct.BitVec.html\" title=\"struct common_base::bit_vec::prelude::BitVec\">BitVec</a>&lt;T, O&gt;<div class=\"where\">where\n    O: <a class=\"trait\" href=\"trait.BitOrder.html\" title=\"trait common_base::bit_vec::prelude::BitOrder\">BitOrder</a>,\n    T: <a class=\"trait\" href=\"trait.BitStore.html\" title=\"trait common_base::bit_vec::prelude::BitStore\">BitStore</a>,\n    <a class=\"struct\" href=\"struct.BitSlice.html\" title=\"struct common_base::bit_vec::prelude::BitSlice\">BitSlice</a>&lt;T, O&gt;: <a class=\"trait\" href=\"trait._.html\" title=\"trait common_base::bit_vec::prelude::_\">BitField</a>,</div></div>"}</script></section></div></main></body></html>