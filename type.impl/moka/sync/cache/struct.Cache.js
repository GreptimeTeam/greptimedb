(function() {
    var type_impls = Object.fromEntries([["mito2",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Cache%3CK,+V%3E\" class=\"impl\"><a href=\"#impl-Cache%3CK,+V%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V&gt; Cache&lt;K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(max_capacity: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>) -&gt; Cache&lt;K, V&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>\n<p>To adjust various configuration knobs such as <code>initial_capacity</code> or\n<code>time_to_live</code>, use the <a href=\"./struct.CacheBuilder.html\"><code>CacheBuilder</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.builder\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">builder</a>() -&gt; CacheBuilder&lt;K, V, Cache&lt;K, V&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a <a href=\"./struct.CacheBuilder.html\"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> or\n<code>SegmentedCache</code> with various configuration knobs.</p>\n</div></details></div></details>",0,"mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; Cache&lt;K, V, S&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.name\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">name</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns cache’s name.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.policy\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">policy</a>(&amp;self) -&gt; Policy</h4></section></summary><div class=\"docblock\"><p>Returns a read-only cache policy of this cache.</p>\n<p>At this time, cache policy cannot be modified after cache creation.\nA future version may support to modify it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entry_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entry_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a></h4></section></summary><div class=\"docblock\"><p>Returns an approximate number of entries in this cache.</p>\n<p>The value returned is <em>an estimate</em>; the actual count may differ if there are\nconcurrent insertions or removals, or if some entries are pending removal due\nto expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>\nfirst.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n\n<span class=\"kw\">let </span>cache = Cache::new(<span class=\"number\">10</span>);\ncache.insert(<span class=\"string\">'n'</span>, <span class=\"string\">\"Netherland Dwarf\"</span>);\ncache.insert(<span class=\"string\">'l'</span>, <span class=\"string\">\"Lop Eared\"</span>);\ncache.insert(<span class=\"string\">'d'</span>, <span class=\"string\">\"Dutch\"</span>);\n\n<span class=\"comment\">// Ensure an entry exists.\n</span><span class=\"macro\">assert!</span>(cache.contains_key(<span class=\"kw-2\">&amp;</span><span class=\"string\">'n'</span>));\n\n<span class=\"comment\">// However, followings may print stale number zeros instead of threes.\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, cache.entry_count());   <span class=\"comment\">// -&gt; 0\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, cache.weighted_size()); <span class=\"comment\">// -&gt; 0\n\n// To mitigate the inaccuracy, Call `run_pending_tasks` method to run\n// pending internal tasks.\n</span>cache.run_pending_tasks();\n\n<span class=\"comment\">// Followings will print the actual numbers.\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, cache.entry_count());   <span class=\"comment\">// -&gt; 3\n</span><span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, cache.weighted_size()); <span class=\"comment\">// -&gt; 3</span></code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.weighted_size\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">weighted_size</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a></h4></section></summary><div class=\"docblock\"><p>Returns an approximate total weighted size of entries in this cache.</p>\n<p>The value returned is <em>an estimate</em>; the actual size may differ if there are\nconcurrent insertions or removals, or if some entries are pending removal due\nto expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>\nfirst. See <a href=\"#method.entry_count\"><code>entry_count</code></a> for a sample code.</p>\n</div></details></div></details>",0,"mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; Cache&lt;K, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.BuildHasher.html\" title=\"trait core::hash::BuildHasher\">BuildHasher</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains_key\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">contains_key</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the cache contains a value for the key.</p>\n<p>Unlike the <code>get</code> method, this method is not considered a cache read operation,\nso it does not update the historic popularity estimator or reset the idle\ntimer for the key.</p>\n<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>\non the borrowed form <em>must</em> match those for the key type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>\n<p>If you want to store values that will be expensive to clone, wrap them by\n<code>std::sync::Arc</code> before storing in a cache. <a href=\"https://doc.rust-lang.org/stable/std/sync/struct.Arc.html\"><code>Arc</code></a> is a\nthread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>\n<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>\non the borrowed form <em>must</em> match those for the key type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entry\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entry</a>(&amp;self, key: K) -&gt; OwnedKeyEntrySelector&lt;'_, K, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Takes a key <code>K</code> and returns an <a href=\"./struct.OwnedKeyEntrySelector.html\"><code>OwnedKeyEntrySelector</code></a> that can be used to\nselect or insert an entry.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n\n<span class=\"kw\">let </span>cache: Cache&lt;String, u32&gt; = Cache::new(<span class=\"number\">100</span>);\n<span class=\"kw\">let </span>key = <span class=\"string\">\"key1\"</span>.to_string();\n\n<span class=\"kw\">let </span>entry = cache.entry(key.clone()).or_insert(<span class=\"number\">3</span>);\n<span class=\"macro\">assert!</span>(entry.is_fresh());\n<span class=\"macro\">assert_eq!</span>(entry.key(), <span class=\"kw-2\">&amp;</span>key);\n<span class=\"macro\">assert_eq!</span>(entry.into_value(), <span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>entry = cache.entry(key).or_insert(<span class=\"number\">6</span>);\n<span class=\"comment\">// Not fresh because the value was already in the cache.\n</span><span class=\"macro\">assert!</span>(!entry.is_fresh());\n<span class=\"macro\">assert_eq!</span>(entry.into_value(), <span class=\"number\">3</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entry_by_ref\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entry_by_ref</a>&lt;'a, Q&gt;(\n    &amp;'a self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;'a Q</a>,\n) -&gt; RefKeyEntrySelector&lt;'a, K, Q, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html\" title=\"trait alloc::borrow::ToOwned\">ToOwned</a>&lt;Owned = K&gt; + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Takes a reference <code>&amp;Q</code> of a key and returns an <a href=\"./struct.RefKeyEntrySelector.html\"><code>RefKeyEntrySelector</code></a> that\ncan be used to select or insert an entry.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n\n<span class=\"kw\">let </span>cache: Cache&lt;String, u32&gt; = Cache::new(<span class=\"number\">100</span>);\n<span class=\"kw\">let </span>key = <span class=\"string\">\"key1\"</span>.to_string();\n\n<span class=\"kw\">let </span>entry = cache.entry_by_ref(<span class=\"kw-2\">&amp;</span>key).or_insert(<span class=\"number\">3</span>);\n<span class=\"macro\">assert!</span>(entry.is_fresh());\n<span class=\"macro\">assert_eq!</span>(entry.key(), <span class=\"kw-2\">&amp;</span>key);\n<span class=\"macro\">assert_eq!</span>(entry.into_value(), <span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>entry = cache.entry_by_ref(<span class=\"kw-2\">&amp;</span>key).or_insert(<span class=\"number\">6</span>);\n<span class=\"comment\">// Not fresh because the value was already in the cache.\n</span><span class=\"macro\">assert!</span>(!entry.is_fresh());\n<span class=\"macro\">assert_eq!</span>(entry.into_value(), <span class=\"number\">3</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_with\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_with</a>(&amp;self, key: K, init: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; V) -&gt; V</h4></section></summary><div class=\"docblock\"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does\nnot exist, evaluates the <code>init</code> closure and inserts the output.</p>\n<h5 id=\"concurrent-calls-on-the-same-key\"><a class=\"doc-anchor\" href=\"#concurrent-calls-on-the-same-key\">§</a>Concurrent calls on the same key</h5>\n<p>This method guarantees that concurrent calls on the same not-existing key are\ncoalesced into one evaluation of the <code>init</code> closure. Only one of the calls\nevaluates its closure, and other calls wait for that closure to complete.</p>\n<p>The following code snippet demonstrates this behavior:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n<span class=\"kw\">use </span>std::{sync::Arc, thread};\n\n<span class=\"kw\">const </span>TEN_MIB: usize = <span class=\"number\">10 </span>* <span class=\"number\">1024 </span>* <span class=\"number\">1024</span>; <span class=\"comment\">// 10MiB\n</span><span class=\"kw\">let </span>cache = Cache::new(<span class=\"number\">100</span>);\n\n<span class=\"comment\">// Spawn four threads.\n</span><span class=\"kw\">let </span>threads: Vec&lt;<span class=\"kw\">_</span>&gt; = (<span class=\"number\">0</span>..<span class=\"number\">4_u8</span>)\n    .map(|task_id| {\n        <span class=\"kw\">let </span>my_cache = cache.clone();\n        thread::spawn(<span class=\"kw\">move </span>|| {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread {task_id} started.\"</span>);\n\n            <span class=\"comment\">// Try to insert and get the value for key1. Although all four\n            // threads will call `get_with` at the same time, the `init` closure\n            // must be evaluated only once.\n            </span><span class=\"kw\">let </span>value = my_cache.get_with(<span class=\"string\">\"key1\"</span>, || {\n                <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread {task_id} inserting a value.\"</span>);\n                Arc::new(<span class=\"macro\">vec!</span>[<span class=\"number\">0u8</span>; TEN_MIB])\n            });\n\n            <span class=\"comment\">// Ensure the value exists now.\n            </span><span class=\"macro\">assert_eq!</span>(value.len(), TEN_MIB);\n            <span class=\"macro\">assert!</span>(my_cache.get(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"key1\"</span>).is_some());\n\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread {task_id} got the value. (len: {})\"</span>, value.len());\n        })\n    })\n    .collect();\n\n<span class=\"comment\">// Wait all threads to complete.\n</span>threads\n    .into_iter()\n    .for_each(|t| t.join().expect(<span class=\"string\">\"Thread failed\"</span>));</code></pre></div>\n<p><strong>Result</strong></p>\n<ul>\n<li>The <code>init</code> closure was called exactly once by thread 1.</li>\n<li>Other threads were blocked until thread 1 inserted the value.</li>\n</ul>\n<div class=\"example-wrap\"><pre class=\"language-console\"><code>Thread 1 started.\nThread 0 started.\nThread 3 started.\nThread 2 started.\nThread 1 inserting a value.\nThread 2 got the value. (len: 10485760)\nThread 1 got the value. (len: 10485760)\nThread 0 got the value. (len: 10485760)\nThread 3 got the value. (len: 10485760)</code></pre></div><h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This method panics when the <code>init</code> closure has panicked. When it happens,\nonly the caller whose <code>init</code> closure panicked will get the panic (e.g. only\nthread 1 in the above sample). If there are other calls in progress (e.g.\nthread 0, 2 and 3 above), this method will restart and resolve one of the\nremaining <code>init</code> closure.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_with_by_ref\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_with_by_ref</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>, init: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; V) -&gt; V<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html\" title=\"trait alloc::borrow::ToOwned\">ToOwned</a>&lt;Owned = K&gt; + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Similar to <a href=\"#method.get_with\"><code>get_with</code></a>, but instead of passing an owned\nkey, you can pass a reference to the key. If the key does not exist in the\ncache, the key will be cloned to create new entry in the cache.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_with_if\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_with_if</a>(\n    &amp;self,\n    key: K,\n    init: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; V,\n    replace_if: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;V</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n) -&gt; V</h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 0.10.0: Replaced with <code>entry().or_insert_with_if()</code></span></div></span></summary><div class=\"docblock\"><p>TODO: Remove this in v0.13.0.\nDeprecated, replaced with\n<a href=\"./struct.OwnedKeyEntrySelector.html#method.or_insert_with_if\"><code>entry()::or_insert_with_if()</code></a></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.optionally_get_with\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">optionally_get_with</a>&lt;F&gt;(&amp;self, key: K, init: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does\nnot exist, evaluates the <code>init</code> closure, and inserts the value if\n<code>Some(value)</code> was returned. If <code>None</code> was returned from the closure, this\nmethod does not insert a value and returns <code>None</code>.</p>\n<h5 id=\"concurrent-calls-on-the-same-key-1\"><a class=\"doc-anchor\" href=\"#concurrent-calls-on-the-same-key-1\">§</a>Concurrent calls on the same key</h5>\n<p>This method guarantees that concurrent calls on the same not-existing key are\ncoalesced into one evaluation of the <code>init</code> closure. Only one of the calls\nevaluates its closure, and other calls wait for that closure to complete.</p>\n<p>The following code snippet demonstrates this behavior:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n<span class=\"kw\">use </span>std::{path::Path, thread};\n\n<span class=\"doccomment\">/// This function tries to get the file size in bytes.\n</span><span class=\"kw\">fn </span>get_file_size(thread_id: u8, path: <span class=\"kw\">impl </span>AsRef&lt;Path&gt;) -&gt; <span class=\"prelude-ty\">Option</span>&lt;u64&gt; {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"get_file_size() called by thread {thread_id}.\"</span>);\n    std::fs::metadata(path).ok().map(|m| m.len())\n}\n\n<span class=\"kw\">let </span>cache = Cache::new(<span class=\"number\">100</span>);\n\n<span class=\"comment\">// Spawn four threads.\n</span><span class=\"kw\">let </span>threads: Vec&lt;<span class=\"kw\">_</span>&gt; = (<span class=\"number\">0</span>..<span class=\"number\">4_u8</span>)\n    .map(|thread_id| {\n        <span class=\"kw\">let </span>my_cache = cache.clone();\n        thread::spawn(<span class=\"kw\">move </span>|| {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread {thread_id} started.\"</span>);\n\n            <span class=\"comment\">// Try to insert and get the value for key1. Although all four\n            // threads will call `optionally_get_with` at the same time,\n            // get_file_size() must be called only once.\n            </span><span class=\"kw\">let </span>value = my_cache.optionally_get_with(\n                <span class=\"string\">\"key1\"</span>,\n                || get_file_size(thread_id, <span class=\"string\">\"./Cargo.toml\"</span>),\n            );\n\n            <span class=\"comment\">// Ensure the value exists now.\n            </span><span class=\"macro\">assert!</span>(value.is_some());\n            <span class=\"macro\">assert!</span>(my_cache.get(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"key1\"</span>).is_some());\n\n            <span class=\"macro\">println!</span>(\n                <span class=\"string\">\"Thread {thread_id} got the value. (len: {})\"</span>,\n                value.unwrap()\n            );\n        })\n    })\n    .collect();\n\n<span class=\"comment\">// Wait all threads to complete.\n</span>threads\n    .into_iter()\n    .for_each(|t| t.join().expect(<span class=\"string\">\"Thread failed\"</span>));</code></pre></div>\n<p><strong>Result</strong></p>\n<ul>\n<li><code>get_file_size()</code> was called exactly once by thread 0.</li>\n<li>Other threads were blocked until thread 0 inserted the value.</li>\n</ul>\n<div class=\"example-wrap\"><pre class=\"language-console\"><code>Thread 0 started.\nThread 1 started.\nThread 2 started.\nget_file_size() called by thread 0.\nThread 3 started.\nThread 2 got the value. (len: 1466)\nThread 0 got the value. (len: 1466)\nThread 1 got the value. (len: 1466)\nThread 3 got the value. (len: 1466)</code></pre></div><h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This method panics when the <code>init</code> closure has panicked. When it happens,\nonly the caller whose <code>init</code> closure panicked will get the panic (e.g. only\nthread 1 in the above sample). If there are other calls in progress (e.g.\nthread 0, 2 and 3 above), this method will restart and resolve one of the\nremaining <code>init</code> closure.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.optionally_get_with_by_ref\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">optionally_get_with_by_ref</a>&lt;F, Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>, init: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html\" title=\"trait alloc::borrow::ToOwned\">ToOwned</a>&lt;Owned = K&gt; + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Similar to <a href=\"#method.optionally_get_with\"><code>optionally_get_with</code></a>, but instead\nof passing an owned key, you can pass a reference to the key. If the key does\nnot exist in the cache, the key will be cloned to create new entry in the\ncache.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_get_with\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_get_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;V, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;E&gt;&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;V, E&gt;,\n    E: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></h4></section></summary><div class=\"docblock\"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does\nnot exist, evaluates the <code>init</code> closure, and inserts the value if <code>Ok(value)</code>\nwas returned. If <code>Err(_)</code> was returned from the closure, this method does not\ninsert a value and returns the <code>Err</code> wrapped by <a href=\"https://doc.rust-lang.org/stable/std/sync/struct.Arc.html\"><code>std::sync::Arc</code></a>.</p>\n<h5 id=\"concurrent-calls-on-the-same-key-2\"><a class=\"doc-anchor\" href=\"#concurrent-calls-on-the-same-key-2\">§</a>Concurrent calls on the same key</h5>\n<p>This method guarantees that concurrent calls on the same not-existing key are\ncoalesced into one evaluation of the <code>init</code> closure (as long as these\nclosures return the same error type). Only one of the calls evaluates its\nclosure, and other calls wait for that closure to complete.</p>\n<p>The following code snippet demonstrates this behavior:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n<span class=\"kw\">use </span>std::{path::Path, thread};\n\n<span class=\"doccomment\">/// This function tries to get the file size in bytes.\n</span><span class=\"kw\">fn </span>get_file_size(thread_id: u8, path: <span class=\"kw\">impl </span>AsRef&lt;Path&gt;) -&gt; <span class=\"prelude-ty\">Result</span>&lt;u64, std::io::Error&gt; {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"get_file_size() called by thread {thread_id}.\"</span>);\n    <span class=\"prelude-val\">Ok</span>(std::fs::metadata(path)<span class=\"question-mark\">?</span>.len())\n}\n\n<span class=\"kw\">let </span>cache = Cache::new(<span class=\"number\">100</span>);\n\n<span class=\"comment\">// Spawn four threads.\n</span><span class=\"kw\">let </span>threads: Vec&lt;<span class=\"kw\">_</span>&gt; = (<span class=\"number\">0</span>..<span class=\"number\">4_u8</span>)\n    .map(|thread_id| {\n        <span class=\"kw\">let </span>my_cache = cache.clone();\n        thread::spawn(<span class=\"kw\">move </span>|| {\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"Thread {thread_id} started.\"</span>);\n\n            <span class=\"comment\">// Try to insert and get the value for key1. Although all four\n            // threads will call `try_get_with` at the same time,\n            // get_file_size() must be called only once.\n            </span><span class=\"kw\">let </span>value = my_cache.try_get_with(\n                <span class=\"string\">\"key1\"</span>,\n                || get_file_size(thread_id, <span class=\"string\">\"./Cargo.toml\"</span>),\n            );\n\n            <span class=\"comment\">// Ensure the value exists now.\n            </span><span class=\"macro\">assert!</span>(value.is_ok());\n            <span class=\"macro\">assert!</span>(my_cache.get(<span class=\"kw-2\">&amp;</span><span class=\"string\">\"key1\"</span>).is_some());\n\n            <span class=\"macro\">println!</span>(\n                <span class=\"string\">\"Thread {thread_id} got the value. (len: {})\"</span>,\n                value.unwrap()\n            );\n        })\n    })\n    .collect();\n\n<span class=\"comment\">// Wait all threads to complete.\n</span>threads\n    .into_iter()\n    .for_each(|t| t.join().expect(<span class=\"string\">\"Thread failed\"</span>));</code></pre></div>\n<p><strong>Result</strong></p>\n<ul>\n<li><code>get_file_size()</code> was called exactly once by thread 1.</li>\n<li>Other threads were blocked until thread 1 inserted the value.</li>\n</ul>\n<div class=\"example-wrap\"><pre class=\"language-console\"><code>Thread 1 started.\nThread 2 started.\nget_file_size() called by thread 1.\nThread 3 started.\nThread 0 started.\nThread 2 got the value. (len: 1466)\nThread 0 got the value. (len: 1466)\nThread 1 got the value. (len: 1466)\nThread 3 got the value. (len: 1466)</code></pre></div><h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>This method panics when the <code>init</code> closure has panicked. When it happens,\nonly the caller whose <code>init</code> closure panicked will get the panic (e.g. only\nthread 1 in the above sample). If there are other calls in progress (e.g.\nthread 0, 2 and 3 above), this method will restart and resolve one of the\nremaining <code>init</code> closure.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_get_with_by_ref\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_get_with_by_ref</a>&lt;F, E, Q&gt;(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>,\n    init: F,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;V, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;E&gt;&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;V, E&gt;,\n    E: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html\" title=\"trait alloc::borrow::ToOwned\">ToOwned</a>&lt;Owned = K&gt; + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Similar to <a href=\"#method.try_get_with\"><code>try_get_with</code></a>, but instead of passing an\nowned key, you can pass a reference to the key. If the key does not exist in\nthe cache, the key will be cloned to create new entry in the cache.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">insert</a>(&amp;self, key: K, value: V)</h4></section></summary><div class=\"docblock\"><p>Inserts a key-value pair into the cache.</p>\n<p>If the cache has this key present, the value is updated.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.invalidate\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>)<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Discards any cached value for the key.</p>\n<p>If you need to get a the value that has been discarded, use the\n<a href=\"#method.remove\"><code>remove</code></a> method instead.</p>\n<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>\non the borrowed form <em>must</em> match those for the key type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove</a>&lt;Q&gt;(&amp;self, key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Q</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;Q&gt;,\n    Q: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Discards any cached value for the key and returns a <em>clone</em> of the value.</p>\n<p>If you do not need to get the value that has been discarded, use the\n<a href=\"#method.invalidate\"><code>invalidate</code></a> method instead.</p>\n<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>\non the borrowed form <em>must</em> match those for the key type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.invalidate_all\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">invalidate_all</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Discards all cached values.</p>\n<p>This method returns immediately by just setting the current time as the\ninvalidation time. <code>get</code> and other retrieval methods are guaranteed not to\nreturn the entries inserted before or at the invalidation time.</p>\n<p>The actual removal of the invalidated entries is done as a maintenance task\ndriven by a user thread. For more details, see\n<a href=\"../index.html#maintenance-tasks\">the Maintenance Tasks section</a> in the crate\nlevel documentation.</p>\n<p>Like the <code>invalidate</code> method, this method does not clear the historic\npopularity estimator of keys so that it retains the client activities of\ntrying to retrieve an item.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.invalidate_entries_if\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">invalidate_entries_if</a>&lt;F&gt;(\n    &amp;self,\n    predicate: F,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>, PredicateError&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html\" title=\"trait core::ops::function::Fn\">Fn</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;K</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;V</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></h4></section></summary><div class=\"docblock\"><p>Discards cached values that satisfy a predicate.</p>\n<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. The\nclosure is called against each cached entry inserted before or at the time\nwhen this method was called. If the closure returns <code>true</code> that entry will be\nevicted from the cache.</p>\n<p>This method returns immediately by not actually removing the invalidated\nentries. Instead, it just sets the predicate to the cache with the time when\nthis method was called. The actual removal of the invalidated entries is done\nas a maintenance task driven by a user thread. For more details, see\n<a href=\"../index.html#maintenance-tasks\">the Maintenance Tasks section</a> in the crate\nlevel documentation.</p>\n<p>Also the <code>get</code> and other retrieval methods will apply the closure to a cached\nentry to determine if it should have been invalidated. Therefore, it is\nguaranteed that these methods must not return invalidated values.</p>\n<p>Note that you must call\n<a href=\"./struct.CacheBuilder.html#method.support_invalidation_closures\"><code>CacheBuilder::support_invalidation_closures</code></a>\nat the cache creation time as the cache needs to maintain additional internal\ndata structures to support this method. Otherwise, calling this method will\nfail with a\n<a href=\"../enum.PredicateError.html#variant.InvalidationClosuresDisabled\"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>\n<p>Like the <code>invalidate</code> method, this method does not clear the historic\npopularity estimator of keys so that it retains the client activities of\ntrying to retrieve an item.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">iter</a>(&amp;self) -&gt; Iter&lt;'_, K, V&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an iterator visiting all key-value pairs in arbitrary order. The\niterator element type is <code>(Arc&lt;K&gt;, V)</code>, where <code>V</code> is a clone of a stored\nvalue.</p>\n<p>Iterators do not block concurrent reads and writes on the cache. An entry can\nbe inserted to, invalidated or evicted from a cache while iterators are alive\non the same cache.</p>\n<p>Unlike the <code>get</code> method, visiting entries via an iterator do not update the\nhistoric popularity estimator or reset idle timers for keys.</p>\n<h5 id=\"guarantees\"><a class=\"doc-anchor\" href=\"#guarantees\">§</a>Guarantees</h5>\n<p>In order to allow concurrent access to the cache, iterator’s <code>next</code> method\ndoes <em>not</em> guarantee the following:</p>\n<ul>\n<li>It does not guarantee to return a key-value pair (an entry) if its key has\nbeen inserted to the cache <em>after</em> the iterator was created.\n<ul>\n<li>Such an entry may or may not be returned depending on key’s hash and\ntiming.</li>\n</ul>\n</li>\n</ul>\n<p>and the <code>next</code> method guarantees the followings:</p>\n<ul>\n<li>It guarantees not to return the same entry more than once.</li>\n<li>It guarantees not to return an entry if it has been removed from the cache\nafter the iterator was created.\n<ul>\n<li>Note: An entry can be removed by following reasons:\n<ul>\n<li>Manually invalidated.</li>\n<li>Expired (e.g. time-to-live).</li>\n<li>Evicted as the cache capacity exceeded.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>moka::sync::Cache;\n\n<span class=\"kw\">let </span>cache = Cache::new(<span class=\"number\">100</span>);\ncache.insert(<span class=\"string\">\"Julia\"</span>, <span class=\"number\">14</span>);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = cache.iter();\n<span class=\"kw\">let </span>(k, v) = iter.next().unwrap(); <span class=\"comment\">// (Arc&lt;K&gt;, V)\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>k, <span class=\"string\">\"Julia\"</span>);\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"number\">14</span>);\n\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.run_pending_tasks\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">run_pending_tasks</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Performs any pending maintenance operations needed by the cache.</p>\n</div></details></div></details>",0,"mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Clone-for-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for Cache&lt;K, V, S&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; Cache&lt;K, V, S&gt;</h4></section></summary><div class=\"docblock\"><p>Makes a clone of this shared cache.</p>\n<p>This operation is cheap as it only creates thread-safe reference counted\npointers to the shared internal data structures.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247\">Source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Cache&lt;K, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/hash/trait.BuildHasher.html\" title=\"trait core::hash::BuildHasher\">BuildHasher</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<section id=\"impl-Send-for-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Send-for-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> for Cache&lt;K, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a>,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a>,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a>,</div></h3></section>","Send","mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"],["<section id=\"impl-Sync-for-Cache%3CK,+V,+S%3E\" class=\"impl\"><a href=\"#impl-Sync-for-Cache%3CK,+V,+S%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, V, S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> for Cache&lt;K, V, S&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a>,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a>,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a>,</div></h3></section>","Sync","mito2::cache::SstMetaCache","mito2::cache::VectorCache","mito2::cache::PageCache","mito2::cache::SelectorResultCache"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[56798]}