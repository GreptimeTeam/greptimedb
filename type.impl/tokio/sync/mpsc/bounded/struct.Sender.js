(function() {
    var type_impls = Object.fromEntries([["mito2",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Clone-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; Sender&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247\">Source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","mito2::sst::index::ResultMpscSender"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","mito2::sst::index::ResultMpscSender"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.send\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">send</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, SendError&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Sends a value, waiting until there is capacity.</p>\n<p>A successful send occurs when it is determined that the other end of the\nchannel has not hung up already. An unsuccessful send would be one where\nthe corresponding receiver has already been closed. Note that a return\nvalue of <code>Err</code> means that the data will never be received, but a return\nvalue of <code>Ok</code> does not mean that the data will be received. It is\npossible for the corresponding receiver to hang up immediately after\nthis function returns <code>Ok</code>.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>If the receive half of the channel is closed, either due to <a href=\"Receiver::close\"><code>close</code></a>\nbeing called or the <a href=\"Receiver\"><code>Receiver</code></a> handle dropping, the function returns\nan error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>If <code>send</code> is used as the event in a <a href=\"crate::select\"><code>tokio::select!</code></a>\nstatement and some other branch completes first, then it is guaranteed\nthat the message was not sent. <strong>However, in that case, the message\nis dropped and will be lost.</strong></p>\n<p>To avoid losing messages, use <a href=\"Self::reserve\"><code>reserve</code></a> to reserve\ncapacity, then use the returned [<code>Permit</code>] to send the message.</p>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>send</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<p>In the following example, each call to <code>send</code> will block until the\npreviously sent value was received.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\ntokio::spawn(<span class=\"kw\">async move </span>{\n    <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n        <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(<span class=\"kw\">_</span>) = tx.send(i).<span class=\"kw\">await </span>{\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"receiver dropped\"</span>);\n            <span class=\"kw\">return</span>;\n        }\n    }\n});\n\n<span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(i) = rx.recv().<span class=\"kw\">await </span>{\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"got = {}\"</span>, i);\n}</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.closed\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">closed</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Completes when the receiver has dropped.</p>\n<p>This allows the producers to get notified when interest in the produced\nvalues is canceled and immediately stop doing work.</p>\n<h5 id=\"cancel-safety-1\"><a class=\"doc-anchor\" href=\"#cancel-safety-1\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. Once the channel is closed, it stays closed\nforever and all future calls to <code>closed</code> will return immediately.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx1, rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n<span class=\"kw\">let </span>tx2 = tx1.clone();\n<span class=\"kw\">let </span>tx3 = tx1.clone();\n<span class=\"kw\">let </span>tx4 = tx1.clone();\n<span class=\"kw\">let </span>tx5 = tx1.clone();\ntokio::spawn(<span class=\"kw\">async move </span>{\n    drop(rx);\n});\n\n<span class=\"macro\">futures::join!</span>(\n    tx1.closed(),\n    tx2.closed(),\n    tx3.closed(),\n    tx4.closed(),\n    tx5.closed()\n);\n<span class=\"macro\">println!</span>(<span class=\"string\">\"Receiver dropped\"</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_send\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_send</a>(&amp;self, message: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, TrySendError&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to immediately send a message on this <code>Sender</code></p>\n<p>This method differs from <a href=\"Sender::send\"><code>send</code></a> by returning immediately if the channel’s\nbuffer is full or no receiver is waiting to acquire some data. Compared\nwith <a href=\"Sender::send\"><code>send</code></a>, this function has two failure cases instead of one (one for\ndisconnection, one for a full buffer).</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<p>If the channel capacity has been reached, i.e., the channel has <code>n</code>\nbuffered values where <code>n</code> is the argument passed to <a href=\"channel\"><code>channel</code></a>, then an\nerror is returned.</p>\n<p>If the receive half of the channel is closed, either due to <a href=\"Receiver::close\"><code>close</code></a>\nbeing called or the [<code>Receiver</code>] handle dropping, the function returns\nan error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"comment\">// Create a channel with buffer size 1\n</span><span class=\"kw\">let </span>(tx1, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n<span class=\"kw\">let </span>tx2 = tx1.clone();\n\ntokio::spawn(<span class=\"kw\">async move </span>{\n    tx1.send(<span class=\"number\">1</span>).<span class=\"kw\">await</span>.unwrap();\n    tx1.send(<span class=\"number\">2</span>).<span class=\"kw\">await</span>.unwrap();\n    <span class=\"comment\">// task waits until the receiver receives a value.\n</span>});\n\ntokio::spawn(<span class=\"kw\">async move </span>{\n    <span class=\"comment\">// This will return an error and send\n    // no message if the buffer is full\n    </span><span class=\"kw\">let _ </span>= tx2.try_send(<span class=\"number\">3</span>);\n});\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>msg;\nmsg = rx.recv().<span class=\"kw\">await</span>.unwrap();\n<span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg);\n\nmsg = rx.recv().<span class=\"kw\">await</span>.unwrap();\n<span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg);\n\n<span class=\"comment\">// Third message may have never been sent\n</span><span class=\"kw\">match </span>rx.recv().<span class=\"kw\">await </span>{\n    <span class=\"prelude-val\">Some</span>(msg) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg),\n    <span class=\"prelude-val\">None </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"the third message was never sent\"</span>),\n}</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_timeout\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">send_timeout</a>(\n    &amp;self,\n    value: T,\n    timeout: <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/time/struct.Duration.html\" title=\"struct core::time::Duration\">Duration</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, SendTimeoutError&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Sends a value, waiting until there is capacity, but only for a limited time.</p>\n<p>Shares the same success and error conditions as <a href=\"Sender::send\"><code>send</code></a>, adding one more\ncondition for an unsuccessful send, which is when the provided timeout has\nelapsed, and there is no capacity available.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">§</a>Errors</h5>\n<p>If the receive half of the channel is closed, either due to <a href=\"Receiver::close\"><code>close</code></a>\nbeing called or the <a href=\"Receiver\"><code>Receiver</code></a> having been dropped,\nthe function returns an error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function panics if it is called outside the context of a Tokio\nruntime <a href=\"crate::runtime::Builder::enable_time\">with time enabled</a>.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<p>In the following example, each call to <code>send_timeout</code> will block until the\npreviously sent value was received, unless the timeout has elapsed.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n<span class=\"kw\">use </span>tokio::time::{sleep, Duration};\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\ntokio::spawn(<span class=\"kw\">async move </span>{\n    <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n        <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(e) = tx.send_timeout(i, Duration::from_millis(<span class=\"number\">100</span>)).<span class=\"kw\">await </span>{\n            <span class=\"macro\">println!</span>(<span class=\"string\">\"send error: #{:?}\"</span>, e);\n            <span class=\"kw\">return</span>;\n        }\n    }\n});\n\n<span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(i) = rx.recv().<span class=\"kw\">await </span>{\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"got = {}\"</span>, i);\n    sleep(Duration::from_millis(<span class=\"number\">200</span>)).<span class=\"kw\">await</span>;\n}</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.blocking_send\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">blocking_send</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, SendError&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Blocking send to call outside of asynchronous contexts.</p>\n<p>This method is intended for use cases where you are sending from\nsynchronous code to asynchronous code, and will work even if the\nreceiver is not using <a href=\"fn@crate::sync::mpsc::Receiver::blocking_recv\"><code>blocking_recv</code></a> to receive the message.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This function panics if called within an asynchronous execution\ncontext.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>tokio::runtime::Runtime;\n<span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel::&lt;u8&gt;(<span class=\"number\">1</span>);\n\n    <span class=\"kw\">let </span>sync_code = thread::spawn(<span class=\"kw\">move </span>|| {\n        tx.blocking_send(<span class=\"number\">10</span>).unwrap();\n    });\n\n    Runtime::new().unwrap().block_on(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"number\">10</span>), rx.recv().<span class=\"kw\">await</span>);\n    });\n    sync_code.join().unwrap()\n}</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_closed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_closed</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if the channel has been closed. This happens when the\n<a href=\"crate::sync::mpsc::Receiver\"><code>Receiver</code></a> is dropped, or when the <a href=\"crate::sync::mpsc::Receiver::close\"><code>Receiver::close</code></a> method is\ncalled.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">42</span>);\n<span class=\"macro\">assert!</span>(!tx.is_closed());\n\n<span class=\"kw\">let </span>tx2 = tx.clone();\n<span class=\"macro\">assert!</span>(!tx2.is_closed());\n\ndrop(rx);\n<span class=\"macro\">assert!</span>(tx.is_closed());\n<span class=\"macro\">assert!</span>(tx2.is_closed());</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">reserve</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;Permit&lt;'_, T&gt;, SendError&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity. Once capacity to send one message is\navailable, it is reserved for the caller.</p>\n<p>If the channel is full, the function waits for the number of unreceived\nmessages to become less than the channel capacity. Capacity to send one\nmessage is reserved for the caller. A <a href=\"Permit\"><code>Permit</code></a> is returned to track\nthe reserved capacity. The <a href=\"Permit::send\"><code>send</code></a> function on <a href=\"Permit\"><code>Permit</code></a> consumes the\nreserved capacity.</p>\n<p>Dropping <a href=\"Permit\"><code>Permit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"cancel-safety-2\"><a class=\"doc-anchor\" href=\"#cancel-safety-2\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>reserve</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// Reserve capacity\n</span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Sending on the permit succeeds\n</span>permit.send(<span class=\"number\">456</span>);\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_many\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">reserve_many</a>(\n    &amp;self,\n    n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;PermitIterator&lt;'_, T&gt;, SendError&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity. Once capacity to send <code>n</code> messages is\navailable, it is reserved for the caller.</p>\n<p>If the channel is full or if there are fewer than <code>n</code> permits available, the function waits\nfor the number of unreceived messages to become <code>n</code> less than the channel capacity.\nCapacity to send <code>n</code> message is then reserved for the caller.</p>\n<p>A <a href=\"PermitIterator\"><code>PermitIterator</code></a> is returned to track the reserved capacity.\nYou can call this <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\"><code>Iterator</code></a> until it is exhausted to\nget a <a href=\"Permit\"><code>Permit</code></a> and then call [<code>Permit::send</code>]. This function is similar to\n<a href=\"Sender::try_reserve_many\"><code>try_reserve_many</code></a> except it awaits for the slots to become available.</p>\n<p>If the channel is closed, the function returns a [<code>SendError</code>].</p>\n<p>Dropping <a href=\"PermitIterator\"><code>PermitIterator</code></a> without consuming it entirely releases the remaining\npermits back to the channel.</p>\n<h5 id=\"cancel-safety-3\"><a class=\"doc-anchor\" href=\"#cancel-safety-3\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve_many</code>\ncomplete in the order they were requested. Cancelling a call to\n<code>reserve_many</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// Reserve capacity\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.reserve_many(<span class=\"number\">2</span>).<span class=\"kw\">await</span>.unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Sending with the permit iterator succeeds\n</span>permit.next().unwrap().send(<span class=\"number\">456</span>);\npermit.next().unwrap().send(<span class=\"number\">457</span>);\n\n<span class=\"comment\">// The iterator should now be exhausted\n</span><span class=\"macro\">assert!</span>(permit.next().is_none());\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n<span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">457</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_owned\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">reserve_owned</a>(self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;OwnedPermit&lt;T&gt;, SendError&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity, moving the <code>Sender</code> and returning an owned\npermit. Once capacity to send one message is available, it is reserved\nfor the caller.</p>\n<p>This moves the sender <em>by value</em>, and returns an owned permit that can\nbe used to send a message into the channel. Unlike <a href=\"Sender::reserve\"><code>Sender::reserve</code></a>,\nthis method may be used in cases where the permit must be valid for the\n<code>'static</code> lifetime. <code>Sender</code>s may be cloned cheaply (<code>Sender::clone</code> is\nessentially a reference count increment, comparable to <a href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html#method.clone\" title=\"method alloc::sync::Arc::clone\"><code>Arc::clone</code></a>),\nso when multiple <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>s are needed or the <code>Sender</code> cannot be\nmoved, it can be cloned prior to calling <code>reserve_owned</code>.</p>\n<p>If the channel is full, the function waits for the number of unreceived\nmessages to become less than the channel capacity. Capacity to send one\nmessage is reserved for the caller. An <a href=\"OwnedPermit\"><code>OwnedPermit</code></a> is returned to\ntrack the reserved capacity. The <a href=\"OwnedPermit::send\"><code>send</code></a> function on <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>\nconsumes the reserved capacity.</p>\n<p>Dropping the <a href=\"OwnedPermit\"><code>OwnedPermit</code></a> without sending a message releases the\ncapacity back to the channel.</p>\n<h5 id=\"cancel-safety-4\"><a class=\"doc-anchor\" href=\"#cancel-safety-4\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>reserve_owned</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<p>Sending a message using an <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// Reserve capacity, moving the sender.\n</span><span class=\"kw\">let </span>permit = tx.reserve_owned().<span class=\"kw\">await</span>.unwrap();\n\n<span class=\"comment\">// Send a message, consuming the permit and returning\n// the moved sender.\n</span><span class=\"kw\">let </span>tx = permit.send(<span class=\"number\">123</span>);\n\n<span class=\"comment\">// The value sent on the permit is received.\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">123</span>);\n\n<span class=\"comment\">// The sender can now be used again.\n</span>tx.send(<span class=\"number\">456</span>).<span class=\"kw\">await</span>.unwrap();</code></pre></div>\n<p>When multiple <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>s are needed, or the sender cannot be moved\nby value, it can be inexpensively cloned before calling <code>reserve_owned</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// Clone the sender and reserve capacity.\n</span><span class=\"kw\">let </span>permit = tx.clone().reserve_owned().<span class=\"kw\">await</span>.unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Sending on the permit succeeds.\n</span>permit.send(<span class=\"number\">456</span>);\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_reserve</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;Permit&lt;'_, T&gt;, TrySendError&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire a slot in the channel without waiting for the slot to become\navailable.</p>\n<p>If the channel is full this function will return [<code>TrySendError</code>], otherwise\nif there is a slot available it will return a <a href=\"Permit\"><code>Permit</code></a> that will then allow you\nto <a href=\"Permit::send\"><code>send</code></a> on the channel with a guaranteed slot. This function is similar to\n<a href=\"Sender::reserve\"><code>reserve</code></a> except it does not await for the slot to become available.</p>\n<p>Dropping <a href=\"Permit\"><code>Permit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// Reserve capacity\n</span><span class=\"kw\">let </span>permit = tx.try_reserve().unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n// fail because there is no capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n<span class=\"comment\">// Sending on the permit succeeds\n</span>permit.send(<span class=\"number\">456</span>);\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve_many\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_reserve_many</a>(\n    &amp;self,\n    n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;PermitIterator&lt;'_, T&gt;, TrySendError&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire <code>n</code> slots in the channel without waiting for the slot to become\navailable.</p>\n<p>A <a href=\"PermitIterator\"><code>PermitIterator</code></a> is returned to track the reserved capacity.\nYou can call this <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\"><code>Iterator</code></a> until it is exhausted to\nget a [<code>Permit</code>] and then call [<code>Permit::send</code>]. This function is similar to\n<a href=\"Sender::reserve_many\"><code>reserve_many</code></a> except it does not await for the slots to become available.</p>\n<p>If there are fewer than <code>n</code> permits available on the channel, then\nthis function will return a [<code>TrySendError::Full</code>]. If the channel is closed\nthis function will return a [<code>TrySendError::Closed</code>].</p>\n<p>Dropping <a href=\"PermitIterator\"><code>PermitIterator</code></a> without consuming it entirely releases the remaining\npermits back to the channel.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// Reserve capacity\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.try_reserve_many(<span class=\"number\">2</span>).unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n// fail because there is no capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n<span class=\"comment\">// Sending with the permit iterator succeeds\n</span>permit.next().unwrap().send(<span class=\"number\">456</span>);\npermit.next().unwrap().send(<span class=\"number\">457</span>);\n\n<span class=\"comment\">// The iterator should now be exhausted\n</span><span class=\"macro\">assert!</span>(permit.next().is_none());\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n<span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">457</span>);\n\n<span class=\"comment\">// Trying to call try_reserve_many with 0 will return an empty iterator\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.try_reserve_many(<span class=\"number\">0</span>).unwrap();\n<span class=\"macro\">assert!</span>(permit.next().is_none());\n\n<span class=\"comment\">// Trying to call try_reserve_many with a number greater than the channel\n// capacity will return an error\n</span><span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">3</span>);\n<span class=\"macro\">assert!</span>(permit.is_err());\n\n<span class=\"comment\">// Trying to call try_reserve_many on a closed channel will return an error\n</span>drop(rx);\n<span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(permit.is_err());\n\n<span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">0</span>);\n<span class=\"macro\">assert!</span>(permit.is_err());</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve_owned\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_reserve_owned</a>(\n    self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;OwnedPermit&lt;T&gt;, TrySendError&lt;Sender&lt;T&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire a slot in the channel without waiting for the slot to become\navailable, returning an owned permit.</p>\n<p>This moves the sender <em>by value</em>, and returns an owned permit that can\nbe used to send a message into the channel. Unlike [<code>Sender::try_reserve</code>],\nthis method may be used in cases where the permit must be valid for the\n<code>'static</code> lifetime.  <code>Sender</code>s may be cloned cheaply (<code>Sender::clone</code> is\nessentially a reference count increment, comparable to <a href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html#method.clone\" title=\"method alloc::sync::Arc::clone\"><code>Arc::clone</code></a>),\nso when multiple <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>s are needed or the <code>Sender</code> cannot be\nmoved, it can be cloned prior to calling <code>try_reserve_owned</code>.</p>\n<p>If the channel is full this function will return a [<code>TrySendError</code>].\nSince the sender is taken by value, the <code>TrySendError</code> returned in this\ncase contains the sender, so that it may be used again. Otherwise, if\nthere is a slot available, this method will return an <a href=\"OwnedPermit\"><code>OwnedPermit</code></a>\nthat can then be used to <a href=\"OwnedPermit::send\"><code>send</code></a> on the channel with a guaranteed slot.\nThis function is similar to  <a href=\"Sender::reserve_owned\"><code>reserve_owned</code></a> except it does not await\nfor the slot to become available.</p>\n<p>Dropping the <a href=\"OwnedPermit\"><code>OwnedPermit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// Reserve capacity\n</span><span class=\"kw\">let </span>permit = tx.clone().try_reserve_owned().unwrap();\n\n<span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n// available capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n<span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n// fail because there is no capacity.\n</span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n<span class=\"comment\">// Sending on the permit succeeds\n</span>permit.send(<span class=\"number\">456</span>);\n\n<span class=\"comment\">// The value sent on the permit is received\n</span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.same_channel\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">same_channel</a>(&amp;self, other: &amp;Sender&lt;T&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if senders belong to the same channel.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n<span class=\"kw\">let  </span>tx2 = tx.clone();\n<span class=\"macro\">assert!</span>(tx.same_channel(<span class=\"kw-2\">&amp;</span>tx2));\n\n<span class=\"kw\">let </span>(tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(!tx3.same_channel(<span class=\"kw-2\">&amp;</span>tx2));</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.capacity\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the current capacity of the channel.</p>\n<p>The capacity goes down when sending a value by calling <a href=\"Sender::send\"><code>send</code></a> or by reserving capacity\nwith <a href=\"Sender::reserve\"><code>reserve</code></a>. The capacity goes up when values are received by the [<code>Receiver</code>].\nThis is distinct from <a href=\"Sender::max_capacity\"><code>max_capacity</code></a>, which always returns buffer capacity initially\nspecified when calling <a href=\"channel\"><code>channel</code></a></p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);\n\n<span class=\"comment\">// Making a reservation drops the capacity by one.\n</span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n<span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">4</span>);\n\n<span class=\"comment\">// Sending and receiving a value increases the capacity by one.\n</span>permit.send(());\nrx.recv().<span class=\"kw\">await</span>.unwrap();\n<span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.downgrade\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">downgrade</a>(&amp;self) -&gt; WeakSender&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts the <code>Sender</code> to a [<code>WeakSender</code>] that does not count\ntowards RAII semantics, i.e. if all <code>Sender</code> instances of the\nchannel were dropped and only <code>WeakSender</code> instances remain,\nthe channel is closed.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_capacity\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">max_capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the maximum buffer capacity of the channel.</p>\n<p>The maximum capacity is the buffer capacity initially specified when calling\n<a href=\"channel\"><code>channel</code></a>. This is distinct from <a href=\"Sender::capacity\"><code>capacity</code></a>, which returns the <em>current</em>\navailable buffer capacity: as messages are sent and received, the\nvalue returned by <a href=\"Sender::capacity\"><code>capacity</code></a> will go up or down, whereas the value\nreturned by <a href=\"Sender::max_capacity\"><code>max_capacity</code></a> will remain constant.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">let </span>(tx, _rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">5</span>);\n\n<span class=\"comment\">// both max capacity and capacity are the same at first\n</span><span class=\"macro\">assert_eq!</span>(tx.max_capacity(), <span class=\"number\">5</span>);\n<span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);\n\n<span class=\"comment\">// Making a reservation doesn't change the max capacity.\n</span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n<span class=\"macro\">assert_eq!</span>(tx.max_capacity(), <span class=\"number\">5</span>);\n<span class=\"comment\">// but drops the capacity by one\n</span><span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">4</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.strong_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">strong_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of [<code>Sender</code>] handles.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.weak_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">weak_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of [<code>WeakSender</code>] handles.</p>\n</div></details></div></details>",0,"mito2::sst::index::ResultMpscSender"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-TrySend-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-TrySend-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; TrySend for Sender&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Message\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Message\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Message</a> = T</h4></section></summary><div class='docblock'>The message that will be sent.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_send\" class=\"method trait-impl\"><a href=\"#method.try_send\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_send</a>(\n    &amp;self,\n    item: &lt;Sender&lt;T&gt; as TrySend&gt;::Message,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, TrySendError&gt;</h4></section></summary><div class='docblock'>Try to send a message batch to a worker thread. <a>Read more</a></div></details></div></details>","TrySend","mito2::sst::index::ResultMpscSender"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[47520]}