mod mysql;

use std::sync::Arc;

use serde::{Deserialize, Serialize};

use self::mysql::{mysql_native_pwd_auth1, mysql_native_pwd_auth2};
use crate::error::Result;

#[async_trait::async_trait]
pub trait UserProvider: Send + Sync {
    fn name(&self) -> String;

    async fn get_user_info(&self, identity: Identity) -> Result<Option<UserInfo>>;
}

pub type UserProviderRef = Arc<dyn UserProvider>;

type Username = String;
type HostOrIp = String;

#[derive(Clone, Serialize, Deserialize)]
pub enum AuthMethod {
    PlainText(Vec<u8>),
    DoubleSha1(Vec<u8>),
}


pub enum Identity {
    UserId(Username, Option<HostOrIp>),
}

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct UserInfo {
    username: String,
    auth_methods: Vec<AuthMethod>,
}

impl UserInfo {
    pub fn new(username: impl Into<String>, auth_methods: Vec<AuthMethod>) -> Self {
        Self {
            username: username.into(),
            auth_methods,
        }
    }

    pub fn get_username(&self) -> String {
        self.username.clone()
    }

    pub fn auth_methods(&self) -> &[AuthMethod] {
        &self.auth_methods
    }

    pub fn mysql_auth_method(&self, auth_plugin: &MysqlAuthPlugin) -> Option<&AuthMethod> {
        self.auth_methods
            .iter()
            .find(|&method| method.support_mysql(auth_plugin))
    }

    pub fn pg_auth_method(&self, auth_plugin: &PgAuthPlugin) -> Option<&AuthMethod> {
        self.auth_methods
            .iter()
            .find(|&method| method.support_pg(auth_plugin))
    }
}

impl AuthMethod {
    /// Get the auth method that supports the specified mysql auth plugin.
    fn support_mysql(&self, auth_plugin: &MysqlAuthPlugin) -> bool {
        match auth_plugin {
            MysqlAuthPlugin::MysqlNativePwd => match self {
                AuthMethod::PlainText(_) => true,
                AuthMethod::DoubleSha1(_) => true,
            },
        }
    }

    /// Get the authentication method that supports the specified pg auth plugin.
    // TODO(fys): remove this
    #[allow(dead_code)]
    fn support_pg(&self, auth_plugin: &PgAuthPlugin) -> bool {
        match auth_plugin {
            PgAuthPlugin::PlainText => match self {
                AuthMethod::PlainText(_) => true,
                AuthMethod::DoubleSha1(_) => false,
            },
        }
    }
}

pub enum MysqlAuthPlugin {
    MysqlNativePwd,
}

/// A function to check hashed value(passed by mysql client) corresponds to the password.
///
/// Note: when an auth_method that does not support auth plugin is passed, it will return
/// false. Suggest to check whether the auth_method supports auth plugin before call this
/// function.
///
/// # Arguments
///
/// * `auth_plugin`  - the type of mysql auth plugin, include **mysql_native_password**.
/// * `hashed_value` - the hashed string passed from mysql client.
/// * `salt`         - the random string generated by the server.
/// * `auth_method`  - it is used to check hashed_value corresponds to the password.
pub fn auth_mysql(
    auth_plugin: MysqlAuthPlugin,
    hashed_value: &[u8],
    salt: &[u8],
    auth_method: &AuthMethod,
) -> bool {
    match auth_plugin {
        MysqlAuthPlugin::MysqlNativePwd => match auth_method {
            AuthMethod::PlainText(plain_text) => {
                mysql_native_pwd_auth2(hashed_value, salt, plain_text)
            }

            AuthMethod::DoubleSha1(hashed_stage2) => {
                mysql_native_pwd_auth1(hashed_value, salt, hashed_stage2)
            }
        },
    }
}

pub enum PgAuthPlugin {
    PlainText,
}

pub fn auth_pg(
    auth_plugin: PgAuthPlugin,
    hashed_value: &[u8],
    _salt: &[u8],
    auth_method: &AuthMethod,
) -> bool {
    match auth_plugin {
        PgAuthPlugin::PlainText => match auth_method {
            AuthMethod::PlainText(plain_text) => plain_text == hashed_value,

            AuthMethod::DoubleSha1(_) => false,
        },
    }
}

#[cfg(test)]
mod tests {
    use super::{auth_mysql, auth_pg, AuthMethod, MysqlAuthPlugin, PgAuthPlugin};

    #[test]
    fn test_auth_pg() {
        let plain_text = b"123456";

        let auth_method = AuthMethod::PlainText(b"123456".to_vec());

        assert!(auth_pg(
            PgAuthPlugin::PlainText,
            plain_text,
            &[],
            &auth_method
        ));
    }

    #[test]
    fn test_auth_mysql() {
        let hash_val = mock_hashed_val();
        let salt = b"1213hjkasdhjkashdjka";

        let plain = AuthMethod::PlainText(b"123456".to_vec());

        assert!(plain.support_mysql(&MysqlAuthPlugin::MysqlNativePwd));

        assert!(auth_mysql(
            MysqlAuthPlugin::MysqlNativePwd,
            &hash_val,
            salt,
            &AuthMethod::PlainText(b"123456".to_vec()),
        ));

        let doublesha1 = AuthMethod::DoubleSha1(mock_hashed_stage2());

        assert!(doublesha1.support_mysql(&MysqlAuthPlugin::MysqlNativePwd));
        assert!(!doublesha1.support_pg(&PgAuthPlugin::PlainText));

        assert!(auth_mysql(
            MysqlAuthPlugin::MysqlNativePwd,
            &hash_val,
            salt,
            &doublesha1,
        ));
    }

    // mock hashed value passes from mysql client
    // hashed value = sha1(pwd) xor sha1(slat + sha1(sha1(pwd)));
    // pwd = b"123456"
    // salt = b"1213hjkasdhjkashdjka"
    fn mock_hashed_val() -> Vec<u8> {
        vec![
            5, 55, 38, 182, 222, 78, 102, 175, 150, 55, 108, 219, 212, 225, 164, 108, 140, 86, 218,
            56,
        ]
    }

    // sha1(sha1(pwd))
    // pwd = b"123456"
    fn mock_hashed_stage2() -> Vec<u8> {
        vec![
            107, 180, 131, 126, 183, 67, 41, 16, 94, 228, 86, 141, 218, 125, 198, 126, 210, 202,
            42, 217,
        ]
    }
}
