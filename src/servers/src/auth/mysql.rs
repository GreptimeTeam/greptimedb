// Copyright 2022 Greptime Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use super::pwd::{sha1, sha1_multi, simple_xor};
use super::AuthMethod;

pub enum MysqlAuthPlugin {
    MysqlNativePwd,
}

/// A function to check hashed value(passed by mysql client) corresponds to the password.
///
/// Note: when an auth_method that does not support auth plugin is passed, it will return
/// false. Suggest to check whether the auth_method supports auth plugin before call this
/// function.
///
/// # Arguments
///
/// * `auth_plugin`  - mysql auth plugin type, include **mysql_native_password**.
/// * `hashed_value` - hashed value passed from mysql client.
/// * `salt`         - random bytes generated by the server.
/// * `auth_method`  - used to check hashed_value corresponds to the password.
pub fn auth_mysql(
    auth_plugin: MysqlAuthPlugin,
    hashed_value: &[u8],
    salt: &[u8],
    auth_method: &AuthMethod,
) -> bool {
    match auth_plugin {
        MysqlAuthPlugin::MysqlNativePwd => match auth_method {
            AuthMethod::PlainText(plain_text) => {
                mysql_native_pwd_auth2(hashed_value, salt, plain_text)
            }

            AuthMethod::DoubleSha1(hashed_stage2) => {
                mysql_native_pwd_auth1(hashed_value, salt, hashed_stage2)
            }
        },
    }
}

// hashed_value: passed from client, calculated by "sha1(pwd) xor sha1(salt + sha1(sha1(pwd)))"
// hashed_stage2: "sha1(sha1(pwd))"
fn mysql_native_pwd_auth1(hashed_value: &[u8], salt: &[u8], hashed_stage2: &[u8]) -> bool {
    // sha1(hashed_value xor sha1(salt + hashed_stage2)) == hashed_stage2
    &sha1(simple_xor(
        &mut sha1_multi(salt, hashed_stage2),
        hashed_value,
    ))[..]
        == hashed_stage2
}

// hashed_value: passed from client, calculated by "sha1(pwd) xor sha1(salt + sha1(sha1(pwd)))"
fn mysql_native_pwd_auth2(hashed_value: &[u8], salt: &[u8], plain_text: &[u8]) -> bool {
    // hashed_value == sha1(pwd) xor sha1(salt + sha1(sha1(pwd)))
    let mut hash_stage1 = sha1(plain_text);
    let hash_stage2 = sha1(&hash_stage1);
    hashed_value == simple_xor(&mut hash_stage1, &sha1_multi(salt, &hash_stage2))
}

#[cfg(test)]
mod tests {
    use crate::auth::mysql::{
        auth_mysql, mysql_native_pwd_auth1, mysql_native_pwd_auth2, sha1, MysqlAuthPlugin,
    };
    use crate::auth::pwd::{sha1_multi, simple_xor};
    use crate::auth::AuthMethod;

    #[test]
    fn test_auth_mysql() {
        let hash_val = mock_hashed_val();
        let salt = b"1213hjkasdhjkashdjka";

        let plain = AuthMethod::PlainText(b"123456".to_vec());

        assert!(plain.support_mysql(&MysqlAuthPlugin::MysqlNativePwd));

        assert!(auth_mysql(
            MysqlAuthPlugin::MysqlNativePwd,
            &hash_val,
            salt,
            &AuthMethod::PlainText(b"123456".to_vec()),
        ));

        let doublesha1 = AuthMethod::DoubleSha1(mock_hashed_stage2());

        assert!(doublesha1.support_mysql(&MysqlAuthPlugin::MysqlNativePwd));

        assert!(auth_mysql(
            MysqlAuthPlugin::MysqlNativePwd,
            &hash_val,
            salt,
            &doublesha1,
        ));
    }

    // mock hashed value passes from mysql client
    // hashed value = sha1(pwd) xor sha1(slat + sha1(sha1(pwd)));
    // pwd = b"123456"
    // salt = b"1213hjkasdhjkashdjka"
    fn mock_hashed_val() -> Vec<u8> {
        vec![
            5, 55, 38, 182, 222, 78, 102, 175, 150, 55, 108, 219, 212, 225, 164, 108, 140, 86, 218,
            56,
        ]
    }

    // sha1(sha1(pwd))
    // pwd = b"123456"
    fn mock_hashed_stage2() -> Vec<u8> {
        vec![
            107, 180, 131, 126, 183, 67, 41, 16, 94, 228, 86, 141, 218, 125, 198, 126, 210, 202,
            42, 217,
        ]
    }

    #[test]
    fn test_mysql_native_pwd_auth() {
        let pwd = b"123456";
        let mut hashed_stage1 = sha1(pwd);
        let hashed_stage2 = sha1(&hashed_stage1);

        let salt = b"1213hjkasdhjkashdjka";

        let hashed_from_client = simple_xor(&mut hashed_stage1, &sha1_multi(salt, &hashed_stage2));

        assert!(mysql_native_pwd_auth1(
            hashed_from_client,
            salt,
            &hashed_stage2
        ));

        assert!(mysql_native_pwd_auth2(hashed_from_client, salt, pwd));
    }
}
