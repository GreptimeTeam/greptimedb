* Author: Dennis Zhuang
* Updated: 2022/12/13

## Motivation
The [PromQL](https://prometheus.io/docs/prometheus/latest/querying/basics/) supported by Prometheus is used widely in cloud-native observability.  We want to enable it natively in the GreptimeDB.
The GreptimeDB already supports [remote read/write protocol for Prometheus](https://docs.greptime.com/user-guide/supported-protocols/prometheus). But it's not good enough for performance and DevOps. We want to implement PromQL in pure Rust, and cooperate reasonably with our query engine and table engine. We want to push computation down  into storage, reducing data transfer and providing the best performance. And also keep compatible with  Prometheus.
## Design(draft)

The PromQL in Prometheus:
![image](https://user-images.githubusercontent.com/14142/206131597-86ef720b-eb01-4a14-a141-b19cb7924d59.png)

Including:
- Parser:  parse the PromQL string into AST. Refer to the source code [parser](https://github.com/prometheus/prometheus/tree/main/promql/parser).
- Engine: contains an [evaluator](https://github.com/prometheus/prometheus/blob/main/promql/engine.go) to eval the AST, querying data from storage and call [functions](https://github.com/prometheus/prometheus/blob/main/promql/functions.go).
- Storage: time series [storage](https://github.com/prometheus/prometheus/blob/main/storage/interface.go), providing data to the engine.

So our design will focus on these three parts too.

### Parser
Looks like Prometheus is using yacc to generate the parser. I think we can use it too. Hand-wiring is another choice, but I think it's not necessary. Using the same [grammar file](https://github.com/prometheus/prometheus/blob/main/promql/parser/generated_parser.y) is a better way to make our parser compatible with Prometheus easily.

### Engine(Evaluator)
The evaluator  is the core part of the engine:
```go
// An evaluator evaluates given expressions over given fixed timestamps. It
// is attached to an engine through which it connects to a querier and reports
// errors. On timeout or cancellation of its context it terminates.
type evaluator struct {
        ctx context.Context

        startTimestamp int64 // Start time in milliseconds.
        endTimestamp   int64 // End time in milliseconds.
        interval       int64 // Interval in milliseconds.

        maxSamples               int
        currentSamples           int
        logger                   log.Logger
        lookbackDelta            time.Duration
        samplesStats             *stats.QuerySamples
        noStepSubqueryIntervalFn func(rangeMillis int64) int64
}
```

The core function is eval:
```go
// eval evaluates the given expression as the given AST expression node requires.
func (ev *evaluator) eval(expr parser.Expr) (parser.Value, storage.Warnings) {
    ....
 }
```

It would be the most complex part of our work.

There are 70 functions at[ functions.go](https://github.com/prometheus/prometheus/blob/main/promql/functions.go).  They can be implemented step by step.

### Storage

TODO

### Test
Prometheus provides a compatible test suite for other implementations. https://github.com/promlabs/promql-compliance-tester
We can use it to test our implementation.

## Milestones

The first milestone may be in 2023, January. Make the PromQL run and let the compatible test cases pass over 60%.
